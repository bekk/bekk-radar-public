I en Java-applikasjon hvor man skal persistere data er det få ting som er mer selvfølgelig å finne enn bruk av Java Persistance API (JPA) - eller Hibernate, som nok er den mest utbredte implementasjonen.

JPA brukes til å håndtere lagring og uthenting av data i relasjonsdatabaser. Motivasjonen bak er det som beskrives som en [impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch); utfordringen med å oversette en relasjonsmodell med rader og kolonner til et objektorientert design med klasser og komposisjon og arv. JPA forsøker å abstrahere bort dette, og idealet er at man kun skal trenge å forholde seg til data og tilstand i objekter. Tilstanden blir så lagret og hentet opp igjen ved hjelp av en beskrivelse av hvordan klasser og felter korresponderer med databaseskjemaet.

Nøkkelproblemet til JPA er at det fungerer litt for godt til de helt enkle casene. Det er veldig tilfredsstillende å kunne kaste noen annotasjoner på enkle domeneobjekter, og merke at de så blir lagret og hentet frem igjen på nærmest magisk vis. Men for mer avanserte relasjoner og spørringer kommer JPA til kort.

Designet på koden som JPA skal forholde seg til blir også veldig begrenset av hva rammeverket klarer å behandle. JPA gir en tett kobling mellom forretningslogikk og database, der objektenes struktur og design er sterkt bundet til hvordan databasen ser ut. Koblingen mellom database og objekter må uttrykkes ved hjelp av annotasjoner - noe som gir liten innsikt i spørringene som gjøres mot databasen og hvilke ringvirkninger som redesign av domeneobjekter faktisk vil gi. Domeneobjekter bør være svært enkle å redesigne, siden de bør endres kontinuerlig for å imøtekomme nye krav. Men siden konsekvensene av endringer i de tilhørende JPA-objektene er uforutsigbare, ender man ofte med ren patching og utvidelser, noe som sjelden er hensiktsmessig. Da får man som regel det verste fra begge verdener; dårlig designet kode og dårlige spørringer.

En gjenganger i applikasjoner som bruker JPA er bruken av store, altomfattende domeneobjekter som brukes til alt, slik at ulike vertikaler av applikasjonen avhenger av hele modellen selv om de kun bruker en del av den. Det er vanskelig å resonnere rundt disse objektene fordi de holder på summen av tilstandene for all funksjonalitet som har et forhold til dem. Det blir også vanskelig å vite om tilstanden i objektene på et gitt tidspunkt gir en riktig representasjon av tilstanden i databasen.

Ettersom JPA først og fremst passer godt kun i enkle caser, er det ikke verdt å dra inn et så stort rammeverk i applikasjonen din i utgangspunktet, og for nye applikasjoner bør man avstå fra JPA. Som alternativ kan man bruke [mikro-ORM-er](https://radar.bekk.no/tech2017/sprak-og-rammeverk/sql-og-mikro-orm), som har en mer lettvekts tilnærming til databasepersistens, eller gjøre enkle spørringer med JDBC (ev. [Spring JDBC Template](http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/jdbc.html)) og SQL. Da har du full kontroll på hva du spør etter, og ikke minst, når ting brekker trenger du ikke å nøste i hvordan et sett med deklarative annotasjoner på generisk og noe magisk vis blir oversatt til en SQL-spørring som ikke er ment å kunne være lesbar for mennesker. Ved å droppe JPA får man et nært forhold til databasemodellen, vet nøyaktig hvilke spørringer som gjøres, kan enkelt utnytte databasespesifikk funksjonalitet i spørringer, og mapping og spørringer eksisterer eksplisitt i koden, er isolerte, og er enkle å feilsøke.