[Backbone](http://backbonejs.org/) representerte et forløsende friskt pust i 2010, da vi alle stod med jQuery-spaghetti til knærne og lurte på hvordan vi skulle klare å håndtere all kompleksiteten i våre stadig voksende webapplikasjoner. Med Models, Collections og Views skulle vi strukturere koden vår i klassisk MVC-stil, mens routeren holdt styr på hvor i applikasjonen brukeren befant seg.

Det var flere ting som manglet i 2010, for eksempel et godt fungerende og utbredt modulsystem. Dette påvirket Backbone til å benytte arv som mekanisme for deling av funksjonalitet. Sammen med den økende graden av kompleksitet i webapplikasjonene som ble laget (som nettopp ble muliggjort av at vi plutselig hadde et mekanisme for å få til litt struktur i kodebasen) ble dette et mareritt med tanke på vedlikeholdbarhet,

Backbone er også farget av sin tid med tanke på måten templates og views er koblet sammen på – eller egentlig mangelen på slik kobling. For å knytte funksjonalitet i et view sammen med elementer i en template kreves det at utviklere gjør en manuell synkronisering av tekststrenger. Dette er kanskje den vanligste kilden til frustrasjon og bugs i en Backbone applikasjon. Vi har lært oss bedre måter å håndtere dette på nå.

En nøkkelegenskap ved komplekse webapplikasjoner som gjør dem vedlikeholdbare er det å kunne delegere ansvar mellom komponenter. I Backbone er dette en veldig manuell og skjør prosess. Mangelen på abstraksjon av livssyklusen for et view, og et løst forhold mellom forelder- og barn-komponenter (samt deres templates) gjør at ansvar ikke blir delegert i stor nok grad. Resultatet er svære views som gjør for mye på en gang, en for stor API-overflate og en for lav grad av gjenbrukbarhet. I alternativene til Backbone er komposisjon often måten dette er løst på.

Et sentralt konsept i Backbone er hendelsesbasert propagering av tilstandsendringer. Dette er et mønster som har en del utfordringer knyttet til komposisjon. Modeller og Views som baserer seg på hendelser for å gjøre endringer i tilstand får en API-overflate som i liten grad lar seg komponere, teste eller gjenbruke. Det er også notorisk vanskelig å spore tilstandsendringer i et slikt oppsett. Det asynkrone aspektet ved hendelsesbasert tilstandsendring gjør det også vanskelig å koordinere tilstandsendringer i applikasjonen din, eksempelvis når det gjelder avledede eller beregnede attributter som har verdier basert på en eller flere andre datakilder som endrer seg asynkront. Denne mekanismen har vist seg å være så kompleks at en implementasjon av den - Object.Observe - er droppet fra det pågående standardiseringsarbeidet av ny funksjonalitet i JavaScript.

En siste spiker i kista for Backbone er at det baserer seg på mange konsepter og -ismer fra Ruby on Rails. Dette var en enkel kamel å svelge tidligere, da vi ikke hadde så mange alternativer. Nå er ikke dette tilfellet lengre, og den mentale avstanden fra Backbones CRUD-orienterte ordlyd til HTTPs verb og Backbones Rails-konvensjoner rundt synkronisering av tilstand blir unødvendig støyete.

Oppsummert så er Backbone et produkt av sin tid. Vi har lært enormt mye av Backbone og skylder bibloteket en hel masse når det gjelder den innovasjonen som har skjedd innen JavaScript-applikasjoner de siste 7 årene. Idag fremstår alternativer som [Elm](https://radar.bekk.no/tech2017/sprak-og-rammeverk/elm), [Angular](https://radar.bekk.no/tech2017/frontend-og-mobil/angular) og [React](https://radar.bekk.no/tech2017/frontend-og-mobil/react) som langt mer solide plattformer å basere en stor webapplikasjon på. Særlig Redux/Elm-arkitekturen skiller seg positivt ut og er allerede i utstrakt bruk på svært mange av våre prosjekter idag. Disse løsningene gir også mer modulære løsninger hvor det er enklere å senere kunne erstatte rammeverk og enkelt-bestanddeler  dersom det skulle oppstå mer egnede alternativer. Dette er viktige aspekter i et fagområde hvor innovasjontakten er svært høy.