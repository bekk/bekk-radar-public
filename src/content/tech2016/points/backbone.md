[Backbone](http://backbonejs.org/) representerte et forløsende friskt pust i 2010, da vi alle stod med jQuery-spaghetti til knærne og lurte på hvordan vi skulle klare å håndtere all kompleksiteten i våre stadig voksende webapplikasjoner. Med Models, Collections og Views skulle vi strukturere koden vår i klassisk MVC-stil, mens routeren holdt styr på hvor i applikasjonen brukeren befant seg.

Det var flere ting som manglet i 2010, for eksempel et godt fungerende og utbredt modulsystem. Dette påvirket Backbone i retning av arv som mekanisme for deling av funksjonalitet. Sammen med en økende grad av kompleksitet i webapplikasjonene vi lager (som igjen ble muliggjort av at vi plutselig hadde et alternativ for struktur) blir dette et mareritt for vedlikeholdbare kodebaser.

Backbone er også farget av tiden det ble laget når det kommer til måten templates og views er koblet sammen – eller mangelen på kobling. For å knytte funksjonalitet i et view sammen med elementer i en template kreves det at utviklerene holder manuell synkronisering av strenger. Dette er kanskje den vanligste kilden til frustrasjon og bugs i en Backbone applikasjon. Vi har lært oss bedre måter å håndtere dette på nå.

En nøkkelegenskap ved komplekse webapplikasjoner som gjør dem vedlikeholdbare er å kunne delegere ansvar mellom komponenter. I Backbone er dette en veldig manuell og skjør prosess. Mangelen på abstraksjon av viewets livssykel og et løst forhold mellom forelder- og barnkomponenter (samt deres templates) gjør at det oftere ikke blir delegert noe ansvar. Resultatet av dette er veldig svære views som har for mange ansvar, for stor API-overflate og lav grad av gjenbrukbarhet. I alternativene nyttes i større grad komposisjon for dette formål.

Et sentralt konsept i Backbone er hendelsesbasert propagering av tilstandsendringer. Dette er et mønster som har en del utfordringer knyttet til komposisjon. Modeller og Views som baserer seg på hendelser for å gjøre endringer i tilstand får en API-overflate som i liten grad lar seg komponere, teste og gjenbruke. Det er også notorisk vanskelig å spore tilstandsendringer i et slikt oppsett. Den asynkrone siden ved hendelsesbasert tilstandsendring gjør det også vanskelig å koordinere tilstandsendringer i applikasjonen din, f.eks. deriverte eller beregnede attributter basert på en eller flere andre datakilder som endrer seg asynkront. Dette mønsteret har vist seg så komplisert at Object.Observe er droppet fra det pågående arbeidet med ny funksjonalitet i JavaScript.

En siste spiker i kista for Backbone er at det baserer seg på mange konsepter og -ismer fra Ruby on Rails. Dette var en enkel kamel å svelge tidligere, da vi ikke hadde så mange alternativer. Nå er ikke dette lenger tilfellet og den mentale avstanden fra Backbones CRUD-orienterte ordlyd til HTTPs verb og Backbones Rails-konvensjoner rundt synkronisering av tilstand blir unødvendig støyete.

Oppsummert så er Backbone et produkt av sin tid. Vi har lært enormt mye av Backbone og skylder bibloteket mye for den innovasjonen som har skjedd innen JavaScript-applikasjoner de siste 6 årene. Idag fremstår alternativer som [Angular](https://radar.bekk.no/tech2016/frontend-og-mobil/angular) og [React](https://radar.bekk.no/tech2016/frontend-og-mobil/react) som langt mer solide plattformer å basere en stor webapplikasjon på. Særlig kombinasjonen React og [Redux](https://radar.bekk.no/tech2016/sprak-og-rammeverk/redux) skiller seg positivt ut og er i utstrakt bruk på svært mange av våre prosjekter idag. Dette gir også et mer modulært system hvor det er enklere å eventuelt erstatte rammeverk og bestanddeler i fremtiden dersom det skulle oppstå mer egnede løsninger. Dette kan være viktig i et fagområde hvor innovasjontakten er svært høy.