{"description":"BEKKs Teknologiradar, publisert juni 2015.","displayDate":null,"id":7,"ingress":"Punktene i radaren er valgt ut med bakgrunn i de utfordringene våre kunder har, erfaringene vi gjør på våre prosjekter, og arbeidet vi gjør i faggruppene våre. Radaren er et bilde av hvordan vi ser på dette landskapet nå, med henblikk på teknologiens potensiale, modenhet og tilgjengelig kompetanse – alt i en norsk kontekst.","levels":[{"id":19,"name":"Avstå","radius":0},{"id":20,"name":"Vurder","radius":0.19825942216867545},{"id":21,"name":"Bruk","radius":0.41053600935501255}],"name":"BEKKs Teknologiradar 2015","numLevels":0,"numPoints":0,"numSectors":0,"oldurl":null,"plugins":[{"id":4,"url":"Scripts\/Plugins\/default.js"}],"pointInfos":[],"points":[{"description":"Mange organisasjoner gjør fortsatt samlede releaser i større eller mindre grad. Dette er som oftest enten store releaser der mange systemer er involvert, eller mindre (men fortsatt samlede) releaser som er planlagt med faste mellomrom.\u000a\u000aStore releaser oppstår gjerne på grunn av sterke avhengigheter mellom systemene, for å forenkle testing på tvers av system, eller fordi man tror det har en organisasjonmessig eller prosessuell fordel. Regelmessige samlede releaser kan ofte være en måte å ha et ryddig og semi-smidig utrullingsregime på i organisasjoner som ikke er rigget for kontinuerlig utrulling.\u000a\u000aSamlede releaser bør unngås, da de medfører unødvendig risiko gjennom at systemer og oppgaver blir sammenkoblet og avhengige av hverandre selv om de i utgangspunktet ikke er det. Prosessen i seg selv medfører dermed en kompleksitet som ikke behøver å være der. Store releaser har i tillegg et ekstra sett med utfordringer: De hindrer en tilnærming til kontinuerlige leveranser, medfører ofte tunge og langvarige testfaser, tvinger frem mye koordinering mellom system\/team\/leverandører, gjør at verdiskapende features blir liggende brakk frem til neste release og at man potensielt gjør for mye før man har mulighet til å verifisere verdi og justere kursen\/omprioritere.","id":12,"levelFactor":0.42690521773862361,"levelId":19,"name":"Samlede releaser","number":1,"sectorFactor":0.73375012250468685,"sectorId":22,"shape":"circle","size":0},{"description":"Vi opplever ofte tradisjonelle datavarehus-løsninger som tunge å jobbe med. Data skal typisk flyttes over via nattlige batcher og det tar gjerne lang tid for dedikerte utviklere å hente ut nye rapporter. Stort sett er det også snakk om proprietære \"Enterprise\"-produkter med dyre lisenser og få lokale eksperter - slik at det blir både dyrt og tidkrevende å gjøre analyser.\u000a\u000aSamtidig ser vi at det har skjedd en revolusjon på Open Source fronten de siste årene. Med en kombinasjon av moderne søke- og databaseteknologi (Elasticsearch, Neo4J osv.), streaming (Spark, Samza osv.) og JavaScript-basert visualisering kan man lage ekstremt kraftige skreddersydde verktøy for analyse og overvåkning av data som kan overgå det tradisjonelle datavarehuset i ytelse og nytteverdi. Vi mener at man i mange tilfeller kan svare på de samme spørsmålene som datavarehuset på en vesentlig billigere og raskere måte med smart bruk av enkle verktøy.","id":15,"levelFactor":0.27029913168313063,"levelId":20,"name":"Skreddersydd datavarehus","number":2,"sectorFactor":0.89283154595446246,"sectorId":22,"shape":"circle","size":0},{"description":"SOA-bølgen for rundt ti år siden dreide seg om å benytte uavhengige og løst koblede komponenter, som kommuniserer i form av tjenester, til å implementere veldefinert og avgrenset forretningslogikk. Høres dette kjent ut?\u000a\u000aTil tross for gode prinsipper og tanker, ble SOA etter hvert et skjellsord. Begrepet ble synonymt med SOAP\/WebServices, og store leverandører drev aggressiv, buzzword-drevet produktsalg av rigide integrasjonsprodukter.\u000a\u000aI det siste har bl.a. REST, mikrotjenester og skyplattformer økt fokuset på en tjenesteorientert arkitektur. SOA er gjenfødt, og denne gang med et sunt fokus på tjenesteorientering der man i større grad klarer å ta ut gevinstene som de gamle prinsippene forespeilet oss.","id":16,"levelFactor":0.4597886510183618,"levelId":21,"name":"Tjenesteorientering","number":3,"sectorFactor":0.28490006471450319,"sectorId":23,"shape":"circle","size":0},{"description":"I en mikrotjeneste-arkitektur deler man opp systemets totale funksjonalitet i mange små og isolerte komponenter som kan rulles ut uavhengig av hverandre. Komponentene er orientert rundt forretnings-funksjoner, eller \"capabilities\", og kommuniserer over en lettvekts-protokoll.\u000a\u000aArkitekturen støtter opp om kvaliteter som oppetid, robusthet, skalering og ytelse, samtidig som uavhengig utviklingstakt mellom komponentene blir naturlig. Arkitekturen gjør det lettere å ta i bruk rett verktøy til rett jobb, raskere ta i bruk ny teknologi og enklere bytte ut utdaterte tjenester uten store kostnader ettersom hver komponent er fokusert, isolert og liten.\u000a\u000aFør man tar steget over til å bruke mikrotjenester er det viktig at man innser implikasjonene. Organisasjonen må tilpasse seg arbeidstakten og en mer distribuert utviklingsmodell. Man trenger også ha god kontroll på alt fra infrastruktur til applikasjonsdrift og ha kapasitet til å håndtere en mengde nye tekniske utfordringer inntil applikasjonsporteføljen har modnet.","id":17,"levelFactor":0.73178538324261233,"levelId":20,"name":"Mikrotjeneste-arkitektur","number":4,"sectorFactor":0.32674654511926265,"sectorId":23,"shape":"circle","size":0},{"description":"Å standardisere gjøres gjerne for å ha noen faste holdepunkter i en systemportefølje som er i konstant bevegelse. Standardisering skal sikre at systemene er forvaltbare og gjenkjennbare på tvers av porteføljen, og at organisasjonen har kontroll - både arkitekturmessig, økonomisk og strategisk.\u000a\u000aMen standardisering betyr også at man låser noe fast og inngår kompromisser, og dermed mister fleksibilitet, endringsevne og mulighet til å velge den optimale løsningen i hvert enkelt tilfelle. Virkeligheten endrer seg raskt, og hvis man standardiserer på feil eller for detaljert nivå, kan valgene raskt bli utdatert og gi en uhensiktsmessig begrensning på løsningene.\u000a\u000aStandardisering bør brukes strategisk. Standardiser på områder hvor det er viktig å sikre stabilitet og kontinuitet, men unngå det på områder hvor man trenger fleksibilitet og optimalt tilpassede løsninger. Standardisering har en pris, og det er ikke et mål i seg selv å standardisere.","id":18,"levelFactor":0.42635006793225488,"levelId":19,"name":"Overdreven standardisering","number":5,"sectorFactor":0.67287634242534822,"sectorId":23,"shape":"circle","size":0},{"description":"Objektive-C, introdusert i 1983, begynner å få en del år på baken. Språket er en utvidelse av C og har til nå vært hovedspråket å benytte seg av for å skrive applikasjoner til operativsystemene iOS og OS X . Med introduksjonen av Swift sommeren 2014 har Apple tatt første steg vekk fra den gamle traveren.\u000a\u000aVi mener Objective-C fortsatt kommer til å være relevant i mange år fremover. I dag er flesteparten av biblioteker rundt iOS- og OS X-plattformen basert på Objective-C. I tillegg er alle apps laget før Swift ble introdusert skrevet i Objective-C. Forvaltning av Objective-C-applikasjoner vil derfor pågå i flere år.\u000a\u000aObjective-C og Swift kan leve side om side i prosjekter. Nye funksjoner i applikasjonen kan bli skrevet i Swift uten å gå i beina på gammel Objective-C-kode. Ønsker man å støtte iOS-versjoner lavere enn iOS7 kreves det at de blir skrevet i Objective-C. En annen faktor er at Swift er i en modningsfase hvor potensielle oppdateringer kan brekke tidligere skrevet kode og innføre ekstra forvaltningskost.","id":19,"levelFactor":0.46284339227320104,"levelId":19,"name":"Objective-C","number":6,"sectorFactor":0.34463394351385529,"sectorId":24,"shape":"circle","size":0},{"description":"On-premise SharePoint 2013 er mye i bruk, og er fortsatt en plattform som Microsoft bruker mye tid på å videreutvikle. Men om man vurderer å gå til anskaffelse av SharePoint, vil vi anbefale å se på Office 365, Microsofts skyløsning som inkluderer SharePoint.\u000a\u000aOn-premise SharePoint gir deg mye mer kontroll og muligheter for skreddersømutvikling enn Office 365, men dette er ikke nødvendigvis et gode ettersom utrulling og drift av skreddersømskode i SharePoint er komplisert og kompetansekrevende. Ny funksjonalitet kommer dessuten nå alltid først i Office 365, og det er usikkert om og når det blir tilgjengelig on-premise. Eksempler på dette er Yammer for sosial funksjonalitet og Delve for enklere navigering i store datamengder. Sist, men ikke minst, når SharePoint kommer i nye versjoner, så kan det ofte være komplekst å gjøre en oppgradering av on-premise løsninger.","id":20,"levelFactor":0.40507236713357464,"levelId":19,"name":"On-premise Sharepoint","number":7,"sectorFactor":0.195236208648027,"sectorId":23,"shape":"circle","size":0},{"description":"Vi har gjort vår andel web-prosjekter med ulike komponent-baserte web-rammeverk og teknologier. Eksempler på dette er Wicket og JSF i Java, Web Forms for .NET, og Lift i Scala. I dag er den komponentorienterte tankegangen på hell, og vi vil anbefale å avstå fra slik teknologi i dag når man starter på nye prosjekter.\u000a\u000aKomponent-baserte rammeverk gjør et forsøk på å abstrahere bort mye av hvordan web-en egentlig fungerer, f.eks. http og request\/response-flyten. Dersom man skal feilsøke, eller utvikle ting rammeverket ikke støtter \"ut av boksen\", må man imidlertid ofte alikevel forholde seg til, og forstå, det som er forsøkt abstrahert bort.\u000a\u000aEn annen utfordring med bruk av rammeverkene er at de gir tett binding mellom frontend og backend. Dette gjør det vanskelig å ha ulik endringstakt på de ulike delene av applikasjonen og det blir problematisk å oppgradere\/bytte ut frontend-rammeverket uavhengig av backend. ","id":21,"levelFactor":0.32251174672199212,"levelId":19,"name":"Komponent-baserte rammeverk","number":8,"sectorFactor":0.75594493876872526,"sectorId":24,"shape":"circle","size":0},{"description":"Med industrialisert IT mener vi en modell som vi av og til ser i svært store prosjekter og virksomheter. Prosjekter anskaffes typisk som \"totalprosjekter\" over en stor avtale, og kjennetegnes av mange spesialiserte delprosjekter og del-team (arkitekt-\/rammeverks-\/drift-\/test-team) i tillegg til mange utviklingsteam. Avstanden fra utviklingsteamene til forretningssiden blir ofte stor. Dette er en tidkrevende og kostbar måte å utvikle IT-systemer på.\u000a\u000aErfaring fra IT-prosjekter viser at flere ressurser ofte ikke betyr økt produktivitet (se Brooks's Law). Likevel ser vi at en del aktører lager prosjektene større enn de trenger å være. Noen ganger kompenseres dette med å bruke offshoring, slik at enhetskostnaden per utviklingstime går ned. Vi mener man bør søke mot å drive prosjekter med mindre, mer selvstendige og tverrfaglige team som er nært tilknyttet forretningssiden. Løsninger bør i størst mulig grad utvikles sammen med de menneskene som skal bruke det. Forretningssiden bør i størst mulig grad eie anskaffelsen av ressurser.","id":22,"levelFactor":0.51065878113157281,"levelId":19,"name":"Industrialisert IT","number":9,"sectorFactor":0.29989452295927654,"sectorId":22,"shape":"circle","size":0},{"description":"Bootstrap er et CSS-bibliotek skapt av Twitter og har vært i utstrakt bruk de senere årene. \u000a\u000aDersom man kun ønsker å raskt lage noe som ser greit ut og ikke har behov for et eget design kan Bootstrap være et godt valg. Man kan også hente konsepter og ideer fra rammeverket og bruke dette som utgangspunkt for egen kode - eksempelvis grid-systemet.\u000a\u000aVi opplever likevel at mange prosjekter før eller senere får et behov for å implementere et eget design. Dette fungerer sjelden bra i samspill med Bootstrap. Det er vanskelig å ta i bruk kun de delene av Bootstrap som passer for en gitt løsning, og resultatet blir kompleks overskriving av stilregler for å holde eget design separert fra standarden i Bootstrap. Til slutt får man en unødvendig stor og lite vedlikeholdbar CSS-kodebase.","id":23,"levelFactor":0.38776555635052778,"levelId":19,"name":"Bootstrap","number":10,"sectorFactor":0.44785708327122442,"sectorId":25,"shape":"circle","size":0},{"description":"Smidig metodikk har over tid gitt verdi og resultater, men det er fortsatt organisasjoner som pakker inn smidig utvikling som ett av stegene i en usmidig prosess. Eksempelvis utarbeides detaljerte krav og design i forkant, og utgjør kontrakter for hva som skal leveres. Så skjer testing og formell akseptanse etter at utviklingen er ferdig. Dette betyr i praksis at utviklingen — samme hvor smidig den er — lever i et vakuum, og bare er et steg i en større prosess som er sekvensiell og vannfallsorientert. \u000a\u000aEt av hovedprinsippene i smidig metodikk er at man gjør kontinuerlig læring og så tilpasser prosesser og arbeidsmåter ut fra erfaringen man har opparbeidet seg. Og at man bygger koblinger mellom komponenter eller prosesser gradvis. Organisasjoner som prøver å jobbe etter smidige prinsipper vil få enda mer verdi ut av metodikken ved å kontinuerlig arbeide med krav, design, utvikling, test og akseptanse.","id":24,"levelFactor":0.589314589588522,"levelId":21,"name":"Smidig i hele organisasjonen","number":11,"sectorFactor":0.20483276469913345,"sectorId":22,"shape":"circle","size":0},{"description":"Med automatisert akseptansetest menes automatiserte tester som verifiserer funksjonalitet som forretningssiden bidrar til å skrive og vedlikeholde. De kan implementeres av utviklerne, men forretningssiden eier testene og kan tolke resultater fra kjøring av testene.\u000a\u000aFor applikasjoner med mye forretnings- eller faglogikk er det fornuftig å ha automatiserte akseptansetester i tillegg til manuelle tester og automatiserte enhets-, integrasjon- og systemtester.\u000a\u000aDet lønner seg å ha forretningslogikken bak klart definerte grensesnitt i applikasjonen slik at de kan nås av de automatiserte akseptansetestene uten å gå via brukergrensesnittet. Automatiserte akseptansetester via brukergrensesnittet (f.eks web tester) er ikke å anbefale, da de er trege, skjøre og gjør det vanskelig å verifisere all implementert logikk. Fokus på automatisert akseptansetest bør inn på et tidlig stadie i et prosjekt slik at design og kode gjøres testbart. \u000a\u000aVerktøy og biblioteker for automatisert akseptansetest er ikke alltid like gode og moderne, men de som har tabell-fokus (f.eks Excel-ark hvor en rad er en test) er ofte effektive. Alternativt kan man lage testene med skreddersøm. Det viktige er at forretningssiden kan lese og forstå testene, samt at det er enkelt å kjøre og forvalte testene i samme versjonskontrollsystem som resten av koden.","id":25,"levelFactor":0.14010673468847532,"levelId":21,"name":"Automatisert akseptansetest","number":12,"sectorFactor":0.27796548309000013,"sectorId":22,"shape":"circle","size":0},{"description":"Mange av de applikasjonene vi forvalter og utvikler i dag tar i bruk en veldig stor andel av tredjeparts biblioteker. Over tid kan det bli oppdaget sikkerhetsfeil i disse tredjeparts bibliotekene eller rammeverkene, og metoden for å utnytte disse feilene blir ofte offentliggjort på nettet. Dette kan medføre at applikasjonen din plutselig har en alvorlig sikkerhetsfeil som det er lett å finne informasjon om hvordan utnyttes.\u000a\u000aFor å følge med hvilke biblioteker eller rammverk som har hvilke sikkerhetsfeil anbefaler vi å integrere et verktøy med f.eks. byggeserver, som gir beskjed når det er oppdaget en sikkerhetsfeil i det aktuelle rammeverket eller biblioteket. OWASP Dependency Check er et prosjekt vi har brukt mye sammen med byggeserver for å automatisk gi beskjed når det blir oppdaget sikkerhetsfeil i noen av de rammeverkene vi bruker. \u000a\u000aMer og mer av applikasjonene i dag kjører på klientsiden i Javascript. Det er derfor viktig og følge med på sikkerhetsfeil som oppstår i Javascript rammeverk eller biblioteker. Til dette formålet har noen ildsjeler i BEKK utviklet Retire.js. Retire.js kan integreres med byggserver eller kjøre som en nettleserplugin og gi beskjed når det oppdages rammeverk eller biblioteker med sårbarheter. ","id":26,"levelFactor":0.14040100034426414,"levelId":21,"name":"Automatisert deteksjon av sårbare biblioteker","number":13,"sectorFactor":0.7005313452085673,"sectorId":22,"shape":"circle","size":0},{"description":"Digitale samhandlingsverktøy for smidig utvikling har kommet for fullt. Midt i denne trenden synes vi Trello er et godt eksempel på et verktøy som forenkler hverdagen til deltakerne i et utviklingsprosjekt. Trello legger opp til deling og diskusjon som et sentralt aspekt. Vi opplever ofte at fleksbiliteten i dette verktøyet gjør at vi finner nye måter å bruke det på, både internt og i prosjekter.\u000aAnkepunktet mot Trello er at det er forholdsvis funksjonsfattig sammenliknet med f.eks. Jira Agile og Jetbrains YouTrack – spesielt når det kommer til rapportering. Vår erfaring er at det glimrende brukergrensesnittet veier opp for det – og at vi finner andre måter å løse rapporteringen på.","id":27,"levelFactor":0.60930885827295256,"levelId":21,"name":"Trello for samhandling","number":14,"sectorFactor":0.76169181858771839,"sectorId":22,"shape":"circle","size":0},{"description":"Tradisjonelt har prosjekter vært bemannet med mange ulike roller: Prosjektleder, teamleder, arkitekt, tech lead, tester, osv. Rollene plasserer ansvar, men har også en del negative sider, bl.a. potensiale for å være en flaskehals, mindre autonomi\/selvorganisering i teamet og muligheten for å introdusere hviskelek mellom de forskjellige partene.\u000a\u000aI moderne prosjekter er også utviklingshastigheten så rask at man sjelden har tid til å samle de ansvarsmessig korrekte beslutningstakerne for hver avgjørelse. I stedet må beslutninger tas kontinuerlig, og de må tas nære det de påvirker og av personer som forstår konsekvensen av det som besluttes. I praksis betyr dette å bygge tverrfaglige og kompetente team, og la de ha myndighet til å ta egne beslutninger.","id":28,"levelFactor":0.7971363720543726,"levelId":21,"name":"Team med beslutningsmyndighet","number":15,"sectorFactor":0.442284123247391,"sectorId":22,"shape":"circle","size":0},{"description":"Vi ser at koden vi vurderer som dårlig kode ofte er den koden som ikke hedrer veletablerte kodeprinsipper. Ved å anvende prinsippene SOLID, Separation of Concerns, DRY, YAGNI, KISS, SLAP og (pragmatisk) DRY opplever vi at koden blant annet blir testbar, vedlikeholdbar, utvidbar og enklere å forstå.\u000a\u000aDette er alle kjente og kjære prinsipper som har hjulpet industrien i mange år, men som vi ser har gått litt i glemmeboken hos mange. Som med alt annet bør prinsippene anvendes med sunn pragmatisme. Forsøk å gå gjennom listen med kodeprinsipper når du gjør kodegjennomganger eller par-programmering. ","id":29,"levelFactor":0.10088966593917004,"levelId":21,"name":"Kodeprinsipper","number":16,"sectorFactor":0.87974431970881,"sectorId":22,"shape":"circle","size":0},{"description":"Ytelsestesting er stebarnet i utviklingsprosjekter. I den grad det gjøres, er det ofte en prosess som krever mye jobb å reprodusere, og det prioriteres fort ned til fordel for forretningsbehov og andre krav. Holdningen er gjerne at man bare kan \"kaste på mer jern\" hvis man får problemer med ytelsen. Virkeligheten er dog noe dystrere: Ytelsesproblem kan være vanskelige å lokalisere, og er ofte vanskelige å løse med mer hardware. Ytelsestester gjøres gjerne rett før lansering, eller enda verre: Etter at problemene viser seg.\u000a\u000aI stadig flere av våre prosjekter forsøker vi å bygge inn ytelesestesting som en del av den kontinuerlige utviklingsprosessen og helst så tidlig som mulig. Det er ikke alltid enkelt, men kontinuerlig testing av ytelse bør vurderes i de fleste prosjekter. \u000a\u000aVi har god erfaring med å bruke Gatling på våre prosjekter og anbefaler alle å investere tid i å øke kompetansen på verktøyet. Vi vil anbefale dette over lignende verktøy som Locust, JMeter og Grinder.","id":30,"levelFactor":0.1459125689632528,"levelId":21,"name":"Kontinuerlig ytelsestesting","number":17,"sectorFactor":0.0971795806950578,"sectorId":22,"shape":"circle","size":0},{"description":"I mange organisasjoner opererer man med ikke-funksjonelle krav, eller kvalitetskrav. Vi opplever ofte at disse kravene er vagt definerte og at de ikke tar form av konkrete oppgaver som man jobber målbevisst for å oppfylle i utviklingsløpet. I en påfølgende testfase gjør man kanskje – eller kanskje ikke – en avsjekk på om eller hvordan enkelte av kravene er oppfylt.\u000a\u000aDersom man mener at kvalitetskrav er viktige, må de behandles deretter og ikke bli en salderingspost. Man bør definere hva man legger i kvalitet og hvilke egenskaper man skal ta hensyn til. ISO 25010-standarden definerer en kvalitetsmodell som kan være et utgangspunkt for oppfølging av kvalitetskrav.\u000a\u000aKravene bør bli egne oppgaver på linje med funksjonelle oppgaver, så man kan jobbe målrettet for å nå dem. Kravene må være målbare slik at de enkelt lar seg verifisere. Da kan man også tilnærme seg kravene gjennom korte iterasjoner eller eksperimenter. ","id":31,"levelFactor":0.31648325366541485,"levelId":21,"name":"Målbare kvalitetskrav","number":18,"sectorFactor":0.8411080283423823,"sectorId":22,"shape":"circle","size":0},{"description":"Vi har hatt smidig anskaffelse på radaren de siste par årene. Nå ser vi at forskningsmiljøet bruker betegnelsen \"trialsourcing\" om omtrent det samme, dvs en anskaffelsesmodell der team fra leverandører i en avgrenset peride konkurrerer om å levere en prototype på en løsning av et forretningsproblem. En slik \"proof-of-concept\" (PoC) varer gjerne noen uker, men vi har avsluttet PoC'er med fullt kjørende løsning på under en uke.\u000a\u000aKundens fordel er at ulike teknologiske plattformer og fremgangsmåter kan testes ut – og sammenliknes – i realistiske omgivelser. Ikke minst får man mulighet til å sammenlikne leverandørenes fremgangsmåte, kompetanse og effektivitet. En studie fra Simula-miljøet viser at kvaliteten på CV'er, tilbudsdokumenter, kundereferanser og ustrukturerte intervjuer i liten grad samsvarer med leverandørens leveranseevne. Nedsiden med trialsourcing er at en PoC må forberedes nøye og krever en god del kompetanse og ressurser hos kunden, og at det gjerne tiltrekker seg færre tilbud fordi det også krever mer av leverandørene.\u000a\u000aVi hadde gjerne sett at en PoC ble grunnlaget for valg av teknologi og leverandør, og skled rett over i et inkrementelt finansiert utviklingsløp. Regelverket for anskaffelser i det offentlige åpner for denne typen prosesser, og vi har sett gode eksempler på bruk i både privat og offentlig sektor.","id":32,"levelFactor":0.20058631706429109,"levelId":21,"name":"Smidig anskaffelse\/Trialsourcing","number":19,"sectorFactor":0.478056288767978,"sectorId":22,"shape":"circle","size":0},{"description":"Når en tjeneste har mange konsumenter er det utfordrende å vite om tjenesten tilfredstiller behovene til alle konsumentene og om en endring av tjenesten bryter en forutsetning hos en av konsumentene. \u000a\u000aConsumer Driven Contracts er en mekanisme for å håndtere dette. Ved bruk av Consumer Driven Contracts leverer konsumentene en kjørbar test-suite av forventninger til tjenesten. Tjenestetilbyder utvikler så tjenesten ved å verifisere funksjonaliteten mot de overleverte test-suitene. Så lenge alle tester kjører står tilbyder fritt til å endre tjenesten.\u000a\u000aTestene bidrar dermed både til å spesifisere tjenesten i utgangspunktet, og som et sikkerhetsnett ved senere endringer i tjenesten.","id":33,"levelFactor":0.43974923090589607,"levelId":21,"name":"Consumer-driven contracts","number":20,"sectorFactor":0.51043545495261755,"sectorId":22,"shape":"circle","size":0},{"description":"Automatisert bygging, testing, release og deploy er en sentral del av kontinuerlige leveranser. Deployment pipeline er en måte å bryte opp denne prosessen i mindre deler for å få rask feedback. Pipelines gir også en god visuell oversikt, en god pekepinn på flaskehalser i prosessen og gjør noe som ofte er komplekst lett forståelig.\u000a\u000aI BEKK har vi flere prosjekter som benytter seg av Deployment Pipelines i forskjellige kontinuerlige integrasjonsservere som TeamCity, Jenkins og Bamboo og vi vil anbefale det for bruk i alle prosjekter. Et annet godt alternativ verdt å se på er Thoughtworks sin Go hvor kjernefunksjonaliteten er sentrert rundt Deployment Pipelines.","id":34,"levelFactor":0.41155788263848347,"levelId":21,"name":"Deployment Pipeline","number":21,"sectorFactor":0.244846966001616,"sectorId":22,"shape":"circle","size":0},{"description":"Et prosjekt er typisk en midlertidig organisasjon som skal levere et gitt produkt for første gang. Når man utvikler software gir dette utgangspunktet risiko på mange områder, så som liten målbar realisering av gevinst, konflikt mellom prosjektets mål og virksomhetens mål, silo-tankegang, stor avstand mellom prosjekt- og linjeorganisasjon, kortsiktig finansieringsmodell, manglende kommunikasjon og utfordringer med overlevering og kunnskapsoverføring.\u000a\u000aDet blir vanskeligere og vanskeligere å se at denne klassiske prosjektmodellen er godt egnet for IT-leveranser som innebærer et stykke skreddersøm. Over tid tror vi denne gjennomføringsmodellen vil forsvinne. MVP-\/Lean Startup-tankegang, i kombinasjon med No-\/DevOp'sy applikasjonsdrift, flytter forvaltningsfasen til starten av utviklingsløpet. Det er derfor enklere å betrakte leveranseteamet som en forvaltningsorganisasjon fra dag én, og heller håndtere prosjektaktige problemstillinger som spesialtilfeller.\u000a\u000aDersom man skal begynne på nye ting anbefaler vi å ikke gjennomføre disse endringene som et prosjekt, men heller se på de alternative gjennomføringsmodellene nevnt over. Vi anbefaler å fase ut den klassiske prosjektorganisasjonen og erstatte denne med flere, mindre enheter med større autonomi. Fokuset bør være på å starte i det små og levere kontinuerlige forbedringer gradvis, og å etablere en voksende organisasjon gradvis - ut fra erfarte behov. ","id":35,"levelFactor":0.18228087743256904,"levelId":20,"name":"Klassisk prosjektgjennomføring","number":22,"sectorFactor":0.15713718491147427,"sectorId":22,"shape":"circle","size":0},{"description":"\"Individuals and interactions over processes and tools.\"\u000a\u000aDe klassiske Smidige prosessene som Scrum passer ikke alltid, og det er lett å komme i en situasjon hvor prosessen som er valgt ikke gjør at man jobber bedre. Hvorfor er det sånn?\u000a\u000aSystemutvikling handler om mennesker som jobber sammen: En uforutsigbar og rotete verden med ideer, problemløsning, diskusjoner, avklaringer, avhengigheter, suksesshistorier osv. Det handler først og fremst om samarbeid mellom mennesker, ikke verktøy og prosesser.\u000a\u000aFor å tilpasse seg ser vi at det er mange team som utarbeider en egen utviklingsprosess (ofte med utgangspunkt i noe annet) og definerer verktøy, flyt og seremonier selv. Da får også  teamet eierskap til sin egen prosess, og denne kan utvikles og utfordres av teamet selv. Teamet må fokusere på samarbeid og kommunikasjon mellom menneskene og ha \"minst mulig prosess\".","id":36,"levelFactor":0.71583491763314311,"levelId":20,"name":"Minst mulig prosess","number":23,"sectorFactor":0.27435064626086736,"sectorId":22,"shape":"circle","size":0},{"description":"Et av nøkkelprinsippene i Lean Startup er validert læring, som i praksis betyr å sjekke om hypotesene dine stemmer. Og det holder ikke å teoretisere rundt dét; man må sette mål i tråd med en av hypotesene, og så utvikle den minste\/enkleste varianten av produktet som kan brukes til å teste måloppnåelsen. Neste skritt er avhengig av resultatet av testingen, men det kan være alt fra å skrinlegge prosjektet til å bygge videre på produktet for å teste den neste hypotesen.\u000a\u000aSmidig utvikling og kontinuerlige leveranser gjør at vi nå er i stand til å levere software raskt, men lager vi de riktige tingene? Leverer vi verdi, eller itererer vi bare på stedet hvil? Selv i store organisasjoner kan prinsippene fra Lean Startup hjelpe prosjekter med å finne ut om de utvikler de rette tingene, og dermed både senke kostnader og øke tilfredsheten blant brukerne.\u000a\u000aMen samtidig gjør testingen av hypotesene — avhengig av resultatet — det mulig at man får enda større endringer i systemet enn det man er vant med i dag. Dette stiller høyere krav til utviklerne som må kunne holde kvaliteten høy på tross av en konstant strøm av endringer. Dette kan håndteres ved å følge gode arkitekturprinsipper og holde applikasjonene så små som mulig.","id":37,"levelFactor":0.52525258851856782,"levelId":20,"name":"Lean startups","number":24,"sectorFactor":0.44587623380605013,"sectorId":22,"shape":"circle","size":0},{"description":"I de tilfellene hvor man ikke parprogrammerer er kodegjennomgang et godt verktøy for å ivareta kodekvalitet, finne eventuelle feil, spre felles forståelse, sørge for at konvensjoner blir fulgt og lignende. Utfordringen er at man ikke har hatt noen særlig gode verktøy for å gjennomføre kodegjennomgangen. Dette har ført til at man har droppet å gjennomføre kodegjennomgang, eller at man har utført dem på en måte som ikke oppfyller målene man har satt seg.\u000a\u000aPull requests er et verktøy som er ment som støtte til åpen kildekode-utviklere som får inn endringer fra andre utviklere, slik at de kan kikke på disse endringene før de eventuelt tar de inn i egen kodebase. Og selv om vi sjelden eller aldri har behov for å innføre en slik sluse inn til egen kodebase internt i et prosjekt så kan man uansett ha god nytte av pull requests for å gjøre selve kodegjennomgang-delen.\u000a\u000aSom alltid: Vær pragmatisk. Det er ikke sikkert kodegjennomgang med pull requests må brukes bestandig. Og som ved annen kodegjennomgang så er det også ved pull requests viktig at man utfører denne så raskt som mulig etter at pull request-en er mottatt.","id":38,"levelFactor":0.5099847259938628,"levelId":20,"name":"Pull-requests","number":25,"sectorFactor":0.62721485766138385,"sectorId":22,"shape":"circle","size":0},{"description":"Kvalitetsmetrikker for kode kan være verdifulle når de brukes riktig. Automatiserte sjekker og rapporter kan raskt og effektivt gi oversikt over store kodebaser og avdekke svakheter eller risiko i struktur, logikk og syntaks.\u000a\u000aDet er imidlertid viktig å bruke slike rapporter på riktig måte. De kan ta tid å sette opp og konfigurere på en måte som sikrer at problemer fanges opp uten at man får falske positiver.\u000a\u000aEt viktig aspekt er hvordan rapportene benyttes. For å skape verdi må resultater fra rapportene tas med som innspill til den kontinuerlige prosessen det er å utvikle og forbedre kode. Vi har i en del tilfeller erfart at det stilles krav til å sette opp slike rapporter, men at de i liten grad blir lest. Det kan også være vanskelig å konfigurere verktøyene (Sonar, PMD, Checkstyle, Findbugs) godt nok til at rapportene fungerer som en pålitelig kilde.\u000a\u000aMetrikker kan brukes til å komplettere den menneskelige delen av kodegjennomganger, men vi anbefaler å kombinere dette med tradisjonell code-review og spesielt pull requests etter modell fra GitHub.","id":39,"levelFactor":0.32894436428268853,"levelId":20,"name":"Kodekvalitetsmetrikker","number":26,"sectorFactor":0.760218663916113,"sectorId":22,"shape":"circle","size":0},{"description":"Scrum er fortsatt den mest brukte metodikken innen smidig utvikling. Etter omtrent 10 år med Scrum mener vi nå at metoden er moden for utfasing. Det er to grunner til dette:\u000a\u000aScrum som metodikk er utfordrende og blir fort for kompleks når metoden tas i bruk i organisasjoner med lite metode-erfaring. Det blir mye nytt å lære seg på en gang, og dette gjør at man som regel ender opp i en situasjon hvor man ikke har fokus på faktisk prosessforbedring, men snarere fokuserer på å prøve å finne ut hvordan Scrum skal implementeres på en “riktig” måte.\u000a\u000aI organisasjoner som er litt mer erfarne medfører Scrum såpass mye overhead at lettere metodikker (f.eks Kanban) eller skreddersøm av en egen prosess ofte blir mer effektivt.\u000a\u000aVi mener at Scrum hverken passer for nybegynnere eller erfarne. Det finnes mange andre bedre alternativer som MVP, Lean Startup og Kanban. Vurder disse og andre alternativer, det finnes ofte bedre og mer effektive måter å rigge prosjekter og prosesser på.\u000a","id":40,"levelFactor":0.47404434708579152,"levelId":19,"name":"Scrum","number":27,"sectorFactor":0.55333725440895154,"sectorId":22,"shape":"circle","size":0},{"description":"JavaScript på backend, via Node.js, har blitt mer og mer utbredt hos store aktører som Paypal, Yahoo! og Netflix. Serverside JavaScript er fortsatt på et tidlig stadium i Norge, i alle fall innenfor en del bransjer og domener.\u000a\u000aEn viktig grunn til å se på Node.js er støtten for asynkronitet og hvordan behov i typiske \"soft realtime\"-systemer enkelt kan dekkes - spesielt i samspill med bruk av WebSockets. Node.js kan for eksempel inngå som en \"backends for frontends\" i en mikrotjeneste-arkitektur. Samtidig må vi ta med at Node.js ikke passer i CPU-tunge løsninger.\u000a\u000aI mange BEKK-prosjekter utgjør JavaScript-kode 50% av kodebasen, så kunnskap og erfaring i å bygge store JavaScript-applikasjoner er nå etablert.\u000a\u000aI år som i fjor har vi i BEKK stor tro på Node.js, men vi tror fortsatt det vil gå litt tid før Node.js blir utbredt på serversiden.","id":41,"levelFactor":0.343661700288896,"levelId":20,"name":"JavaScript på backend","number":28,"sectorFactor":0.398553594641348,"sectorId":23,"shape":"circle","size":0},{"description":"Med lettvekts virtualiseringsplattformer mener vi containerteknologier som Docker og Rocket, samt større koordineringsløsninger bygget rundt disse, som Deis, Kubernetes, Mesos og Marathon. Dette er teknologier som gjør PaaS tilgjengelig for alle ved å fjerne kompleksiteten i å administrere forskjellige virtuelle maskiner for hver applikasjon.\u000a\u000aLettvekts virtualisering stiller færre garantier rundt f.eks. sikkerhet og muligheten til å kjøre forskjellige operativsystemkjerner for hver applikasjon. Til gjengjeld oppnår man enklere oppsett og administrasjon, bedre ytelse, og en enkel måte å komme i gang med det Martin Fowler kaller Immutable Servers. Etter hvert som man blir komfortabel med teknologien kan dette føre til forenklede prosesser i både utvikling, test og utrulling. Mange store aktører satser på dette forholdsvis nye segmentet, og vi tror det er verdt å følge nøye med på utviklingen her.","id":42,"levelFactor":0.75208791033980882,"levelId":20,"name":"Lettvekts virtualiseringsplatformer","number":29,"sectorFactor":0.51446614080643194,"sectorId":23,"shape":"circle","size":0},{"description":"Legg inn sensorer i applikasjonen som gir beskjed når en bruker forsøker å foreta handlinger som ikke er tillatt. Dette er for eksempel innsending av negative verdier, forsøk på å aksessere områder brukeren ikke har tilgang til eller for mange feilede innlogginger. Angrepsdeteksjon kan bruke terskelverdier som fører til advarsler eller automatiske responser som besluttes basert på alvorlighetsgraden av hendelsene. OWASP AppSensor (https:\/\/www.owasp.org\/index.php\/OWASP_AppSensor_Project) er en god guide og referanse-implementasjon av angrepsdeteksjon.\u000a\u000aDette er ikke noe som passer for alle prosjekter, men det er noe vi har implementert med hell på sikkerhetskritiske løsninger. Nøkkelen er at det krever en del tuning og oppfølging etter implementasjon. Hvis du er klar for å ta inn dette som en del av arbeidsflyten din er det en god ide, men det bør ikke være noe du lager som en ettertanke.\u000a","id":43,"levelFactor":0.49515167996133269,"levelId":20,"name":"Angrepsdeteksjon","number":30,"sectorFactor":0.7293556701737467,"sectorId":23,"shape":"circle","size":0},{"description":"Bruk av skallsikring og produkter som OpenAM eller Oracle Access Manager gir deg mulighet til å flytte autentisering og autorisering på utsiden av applikasjonen, i stedet for å integrere autentisering og autorisasjon i selve applikasjonen. Dette kan gi kan gi fordeler når du har flere applikasjoner som krever autentisering og autorisasjon. I stedet for å implementere autentisering og autorisasjon i applikasjonen kan du legge dette på utsiden av applikasjonen, noe som igjen muliggjør gjenbruk hvis flere applikasjoner har samme behov. \u000a\u000aI BEKK har vi på noen prosjekter tatt i bruk skallsikring med positiv erfaring. Det er dog viktig å ta hensyn til hvor mange applikasjoner som skal skallsikres og kjennskap til produktet som skal brukes til å skallsikre, før man begynner med implementasjon.","id":44,"levelFactor":0.3445434135142888,"levelId":20,"name":"Skallsikring","number":31,"sectorFactor":0.89094681475497484,"sectorId":23,"shape":"circle","size":0},{"description":"Docker er en åpen plattform for å bygge, kjøre og distribuere applikasjoner. Den er uten tvil den mest populære systemkontaineren på markedet for tiden og har et meget aktivt felleskap på hub.docker.com. Immutable kontainere er veldig i vinden i Devops-sammenheng og vi i BEKK ser et stort potensial i tankegangen. At Docker er godt forbi versjon 1 og inkludert fra og med versjon 7 av RedHat Enterprise Linux taler godt for at det er klart for applikasjoner i produksjon.\u000a\u000aVi ser dog at det fortsatt er kjente og ukjente utfordringer sikkerhetsmessig, det kan være seg manglende sikkerhetsoppdateringer eller bruk av docker-images med bakdører i. Vi synes Docker er vel verdt å se på, men gå fram med forsiktighet.","id":45,"levelFactor":0.76157047105821807,"levelId":20,"name":"Docker","number":32,"sectorFactor":0.0803864134881086,"sectorId":23,"shape":"circle","size":0},{"description":"Event Store er en immutable database som lagrer data som en serie av hendelser over tid. Dette gjør det enkelt å implementere applikasjoner som er basert på event sourcing. Noen av fordelene med applikasjoner som er basert på event sourcing er at de er enklere å teste, man kan gjenoppbygge tilstand, hendelser kan spilles av på nytt og man får en full auditlog av alt som skjer i systemet.\u000a\u000aEvent Store har projeksjoner innebygd som gjør det mulig å kombinere eventer fra flere forskjellige \"streams\" eller bygge nye \"streams\" med eventer fra en stream. Event Store er open source, kjører på Windows, Linux og OS X, og det finnes klienter til .NET, Java og Erlang.","id":46,"levelFactor":0.31021958259956867,"levelId":20,"name":"Event Store","number":33,"sectorFactor":0.57734403362498421,"sectorId":23,"shape":"circle","size":0},{"description":"HATEOAS er den mest avanserte formen for REST. Mens mange REST-APIer i praksis er RPC à là WebServices, bruker man her hypermedia til å veilede API-klientene videre i flyten. I utgangspunktet skal klienten bare trenge å vite base-URI til API-et uten noe mer informasjon om hvordan API-et ser ut eller fungerer. Dette gir en svakere binding mellom konsument og tilbyder av API-et, og gjør det lettere å gjøre endringer. \u000a\u000aHATEOAS krever et gjennomtenkt API, en arkitektur som støtter opp om det, samt høy modenhet på klientsystemene. Terskelen kan være høy, men man kan få stor gevinst i form av god arkitektur og svake bindinger mellom systemene. I modne organisasjoner bør HATEOAS vurderes sterkt dersom man ønsker å lage gode og vedlikeholdbare API-er, speiselt de som er offentlig tilgjengelige eller som har mange ulike konsumenter. ","id":47,"levelFactor":0.28870374905446378,"levelId":20,"name":"HATEOAS (Hypermedia as the Engine of Application State)","number":34,"sectorFactor":0.12667322530377267,"sectorId":23,"shape":"circle","size":0},{"description":"Elasticsearch er ikke bare en søkemotor, men også en meget kraftig NoSQL-database. Elasticsearch passer best som horisontalt skalerende dokumentdatabase og den takler svært store datamengder og mye lese- og skrivetrafikk.\u000a\u000aI BEKK brukes Elasticsearch i mange prosjekter, både som søkeløsning og som database. Vår erfaring er at Elasticsearch sine gode REST-api-er, enkle skalerbarhet, og komplette funksjonalitet (spesielt aggregations, shard allocation awareness og backup) gjør produktet til en komplett løsning som dekker mange behov - også når det gjelder god ressursutnyttelse og driftbarhet.\u000a\u000aSe gjerne på plugins som Marvel og Kopf når du skal jobbe med Elasticsearch.","id":48,"levelFactor":0.13633922503009197,"levelId":21,"name":"Elasticsearch","number":35,"sectorFactor":0.88935477112821115,"sectorId":23,"shape":"circle","size":0},{"description":"I tradisjonelle systemutviklingsprosjekter baserer man seg ofte på at arkitekturen defineres på et detaljert nivå før utviklingsløpet begynner - gjerne gjennom en kombinasjon av tidlig detaljplanlegging og vedtatte standarder for teknologi og produkter.\u000a\u000aEn slik fremgangsmåte harmonerer dårlig med et smidig leveranseregime og selvdrevne team som har ansvar for egne systemer. Rigide rammer på feil nivå  fjerner muligheten til å velge optimal arkitektur og teknologi i hvert enkelt tilfelle.\u000a\u000aArkitektur bør utarbeides gradvis og iterativt ved at man til enhver tid gjør de valg som trengs for å komme videre i prosessen. Videre bør arkitektur på et gitt nivå sette overordnede rammer for arkitekturen på nivået under uten å begrense handlingsrommet unødig. Ettersom virkeligheten stadig endrer seg bør man etterstrebe en arkitektur som tåler endringer og kan justeres over tid.","id":49,"levelFactor":0.74139860062675478,"levelId":21,"name":"Just-in-time arkitektur","number":36,"sectorFactor":0.31661820686938874,"sectorId":23,"shape":"circle","size":0},{"description":"Mange prosjekter leveres uten å ta hensyn til langsiktige arkitekturmålbilder, eller gjøres så store at de omfatter hele målbildet. Dette gir ofte  løsninger som bryter med langsiktige målbilder, eller veldig store prosjekter med tilhørende utfordringer. \u000a\u000aEn bedre fremgangsmåte er å definere transisjonsarkitekturer for å arbeide mot de langsiktige målbildene. Dette er milepæler og delmål som ivaretar retning og bevissthet på veien mot det langsiktige målbildet. \u000a\u000aVår erfaring er at bruk av målbilder og transisjonsarkitekturer kan bidra til at leveranser beveger seg mot, og ikke bort fra, langsiktige mål og strategier.","id":50,"levelFactor":0.62214710322139866,"levelId":21,"name":"Transisjonsarkitektur","number":37,"sectorFactor":0.788247727665241,"sectorId":23,"shape":"circle","size":0},{"description":"Office 365 er en skyløsningen fra Microsoft som gir tilgang til Exchange, Office-programmene, Lync og SharePoint. I Office 365 kan man lage skreddersydde SharePoint-løsninger ved å tilpasse utseende, konfigurere funksjonalitet og utvikle apps. \u000a\u000aApp-utvikling for Office 365 er vesentlig forskjellig fra on-premise SharePoint, der koden tradisjonelt kjørte på samme servere som SharePoint.\u000a\u000aFor Office 365 lages apps via REST-api’et eller via CSOM (Client Side Object Model). Man kan velge å utvikle i Javascript eller C#, og funksjonalitet og utviklerverktøy begynner å komme på høyde med on-premise SharePoint. Microsoft slipper dessuten løpende ny funksjonalitet i Office 365. Dermed er oppgradering gått fra å være en av de største utfordringene med SharePoint til å være en ikke-sak.","id":51,"levelFactor":0.50198572756327253,"levelId":21,"name":"Office 365 (SharePoint Online)","number":38,"sectorFactor":0.5587786800596809,"sectorId":23,"shape":"circle","size":0},{"description":"Vi mener oppgaveorienterte verktøy som Gradle er bedre skikket enn pluginbaserte verktøy som Maven og Ant til byggerelaterte oppgaver i prosjekter. Groovy er en mer lesbar måte å uttrykke prosjektets oppgaver på enn XML, man kan utføre flere oppgaver og man utvikler seg i takt med prosjektets livssyklus. \u000a\u000aAnerkjente firmaer som Netflix, SpringFramework og LinkedIn benytter seg i stor grad av Gradle for sine Java-prosjekter. BEKK har også god erfaring med å bruke Gradle som en sentral byggesten i flere prosjekter og vi ser at det kan brukes til mer enn å bare bygge Java-pakker. Verktøyet er meget modent, hyppig utviklet, har masse plugins og vel verdt å ta en titt på som arvtaker for Maven.","id":52,"levelFactor":0.11416575440078126,"levelId":21,"name":"Gradle","number":39,"sectorFactor":0.715268219651751,"sectorId":23,"shape":"circle","size":0},{"description":"Med infrastruktur som kode bærer provisjoneringskoden ofte preg av at man blander logikk og data på samme abstraksjonsnivå. Ved å behandle infrastruktur som data lar man logikken avhenge av datastrukturer, definert i f.eks. en database eller en YML-fil. Dataene beskriver hvordan systemene skal se ut i enkle maskinlesbare formater. Dataformatene eksekveres og sikrer at infrastrukturen matcher beskrivelsen. \u000a\u000aResultatet er konfigurasjon som er fleksibel, lett å prototype, enkel å revidere, og lett å vedlikeholde. \u000a\u000aInfrastruktur som data er støttet av rammeverk som Ansible, Salt, og i nyere tid også Puppet.","id":53,"levelFactor":0.13438854885802273,"levelId":21,"name":"Infrastruktur som data","number":40,"sectorFactor":0.54732051246855951,"sectorId":23,"shape":"circle","size":0},{"description":"ZooKeeper er en open source implementasjon av en distribuert lås, basert på en sterk konsensusalgoritme. ZooKeeper brukes ofte til synkronisering av tjenester i et cluster, leader election, og som en trygg distribuert kø. Dette fungerer godt på ZooKeeper sin side, men kan på grunn av problemets natur være vanskelig å implementere korrekt. I BEKK bruker vi ZooKeeper med suksess i flere prosjekter.\u000a\u000aVær oppmerksom på at fordi ZooKeeper også kan fungere som en transaksjonell key\/value store, bruker noen det til andre tjenester som for eksempel datalager, cache eller service registry. I dette domenet finnes det ofte bedre løsninger.","id":54,"levelFactor":0.094022027293238442,"levelId":21,"name":"ZooKeeper","number":41,"sectorFactor":0.3831930314453183,"sectorId":23,"shape":"circle","size":0},{"description":"Hyppig deploy medfører at hver leveranse inneholder færre endringer. Med færre endringer er det mindre som kan gå galt. Leveransene blir enklere og mindre tidkrevende å teste, og forståelsen av potensielle sideeffekter er større. Den totale mengden testing som er nødvendig reduseres dramatisk og kvaliteten på det som leveres heves med økt forståelse av hva som bør testes og hvordan.\u000a\u000aMonitorering bringer testing, verifisering og helsesjekk nærmest mulig produksjonssystemene. Mye av det som kan gå galt er betydelig vanskeligere å forutse, reprodusere eller legge merke til i et testmiljø. Derfor er det viktig at systemet verifiseres i produksjon hvor det virkelig gjelder.\u000a\u000aKombinert med evnen til å deploye raskt vil monitorering dekke store deler av behovet for testing av endringer. Feil eller andre problemer i produksjon oppdages raskest mulig og kan fikses raskt.","id":55,"levelFactor":0.10056144646389852,"levelId":21,"name":"Monitorering og hyppig deploy fremfor uttømmende testing","number":42,"sectorFactor":0.21064648227895769,"sectorId":23,"shape":"circle","size":0},{"description":"For å oppnå og sikre stabil funksjonalitet og god ytelse må man oppdage unormal oppførsel i applikasjoner og infrastruktur tidlig på tvers av tjenester. Ved å visualisere ulike metrikker fra applikasjoner, kjøretidsmiljø og infrastruktur over tid kan man oppdage usunne trender tidlig, og samtidig få verdifull ny innsikt i hvordan applikasjonene faktisk brukes og kjører.\u000a\u000aFor å få til dette må både applikasjoner og infrastruktur tilby uthenting av metrikker og man må visualisere og sammenstille metrikkene f.eks. i et dashboard. Dropwizard Metrics er et godt metrikkrapporteringsverktøy, mens Kibana, Graphite og Grafana er gode verktøy for visualisering.","id":56,"levelFactor":0.10639346679034752,"levelId":21,"name":"Visualisering av metrikker","number":43,"sectorFactor":0.060228836486248487,"sectorId":23,"shape":"circle","size":0},{"description":"I en hendelsesdrevet (\"event driven\") arkitektur, agerer systemet asynkront idet en gitt hendelse inntreffer i stedet for gjennom eksplisitte operasjoner eller metodekall. Dette brukes i utstrakt grad i JavaScript, for eksempel ved å reagere på hendelser i brukergrensesnittet. Men hendelsesdrevet arkitektur kan også benyttes i andre deler av systemet, slik at asynkrone hendelser medfører operasjoner eller endringer i datamodellen. \u000a\u000aDen asynkrone naturen gir et godt grunnlag for skalering, parallellisering og toleranse for feil eller nedetid. Ulemper som bør nevnes, er at at man kan få en litt mer uoversiktlig arkitektur der det kan være vanskelig å følge flyten, og at det kan være vanskeligere å ha kontroll på rekkefølgen av operasjoner.","id":57,"levelFactor":0.36052971407219847,"levelId":21,"name":"Hendelsesdrevet arkitektur","number":44,"sectorFactor":0.88954918852096632,"sectorId":23,"shape":"circle","size":0},{"description":"Polyglot lagring handler om å bruke det beste verktøyet for å løse et gitt behov. Relasjonelle databaser og SQL har lenge vært måten lagring har blitt gjort på, men utviklingen på internett og nye bruksområder har ført til krav som en tradisjonell relasjonsdatabase har utfordringer med å tilfredsstille.  Å velge en data- og lagringsmodell laget spesifikt for behovet gjør at man unngår kompromisser.\u000a\u000aMange nye databaser og varianter har kommet på banen (key\/value, dokument, graf) og den senere tiden ser vi at polyglot lagring også i større grad kommer innebygget i ett og samme produkt. For eksempel støtter PostgreSQL JSON i dokumentdatabaser og har for ikke lenge siden lansert meget gode api-er for dette. ArrangoDB, OrientDB og andre nykommere er designet fra starten av som polyglot databaser.\u000a\u000aVi tror at polyglot lagring er en løsning for fremtiden og flere prosjekter har allerede høstet gode erfaringer. Vi vil se mer av at de etablerte produsentene bekrefter denne retningen NoSQL har staket ut ved at de implementerer mer polyglot lagring i sine produkter.","id":58,"levelFactor":0.31125962871440177,"levelId":21,"name":"Polyglot databaseløsninger","number":45,"sectorFactor":0.68066894120346633,"sectorId":23,"shape":"circle","size":0},{"description":"Grafdatabaser er nå modent. Der vi tidligere så at kunder brukte denne typen teknologi i prototyper og småprosjekter, beveger bruken seg nå i større grad over på forretnings- og driftskritiske applikasjoner.\u000a\u000aGrafdatabaser gjør det mulig å løse avanserte problemstillinger i relasjonstunge data på nye måter og i en helt annen grad enn andre databasetyper kan tilby. Når Gartner siden 2013, har inkludert grafdatabaser i sin \"Magic Quadrant for Operational Database Management Systems\" (OrientDB siden 2013 og Neo4J siden 2014) vitner dette om at modningen vi ser hos våre kunder skjer i store deler av markedet.\u000a\u000aNeo4J, Titan og OrientDB er de største aktørene på grafdatabasemarkedet, med Neo4J på en klart dominerende plass. Dette er en situasjon vi ser går igjen ved valg av løsning også hos våre kunder. De viktigste vurderingene som gjøres ved slike valg er gjerne knyttet til skaleringsbehov, lisensiering og tilgang på kompetanse.","id":59,"levelFactor":0.30056765902968846,"levelId":21,"name":"Grafdatabaser","number":46,"sectorFactor":0.4581773903899366,"sectorId":23,"shape":"circle","size":0},{"description":"Automatisering av miljø og utrulling kan spare tid og frustrasjon, og er en forutsetning for hyppigere produksjonssetting. En fleksibel infrastuktur (i form av IaaS eller PaaS-løsninger) kan bidra til dette, men er strengt tatt ikke nødvendig.\u000a\u000aEn privat PaaS-løsning vil kunne gi store fordeler ved utrulling og oppsett av applikasjoner, både ved produksjonssetting og under utvikling. Det siste året har mange private sky-produkter modnet kraftig, som et resultat av at microcontainer-teknologien har økt i popularitet. Markedet satser kraftig, og mange respektable aktører setter sin tillit til privat sky. Terskelen for eksperimentering med oppsettet er lav, og det er potensiale for å forenkle utviklingsløp og kontinuerlig utrulling betraktelig.","id":60,"levelFactor":0.27012293759358369,"levelId":21,"name":"Private cloud","number":47,"sectorFactor":0.262224331865753,"sectorId":23,"shape":"circle","size":0},{"description":"En logg-aggregator samler informasjonen fra applikasjons- og serverlogger fra  forskjellige maskiner, applikasjoner og miljø. Loggene sammenstilles, vises og er søkbare fra et felles dashboard, noe som gir muligheter for å finne feil raskt og effektivt. Tradisjonelt sett logger applikasjoner til fil, men mulighetene disse råloggene gir er begrenset. Ofte er loggene applikasjonens eneste mulighet til å si fra om hva som har skjedd i produksjon, og en logg-aggregator er et viktig verktøy når det oppstår feil i produksjon og gjør det mulig å respondere raskt. Spesielt i prosjekter med mange applikasjoner, eller i prosjekter med en micro-service arkitektur, er et logg-aggregeringsverktøy en nødvendighet.\u000a\u000aEn logg-aggregator har mange bruksområder og man kan tilpasse visningen til forskjellige bruksområder som overvåkning, debugging, feilsøking, eller statistikk og trendanalyser. Vi har hatt god erfaring med logg-aggregatorer i flere prosjekter som har applikasjoner med hundretusenvis av brukere hver dag. \u000a\u000aSplunk er et godt produkt som er enkelt å sette opp og konfigurere, men har en aggressiv lisensieringsmodell. Det finnes veldig gode, open-source alternativer, og en vanlig teknologistack er Elasticsearch, Logstash og Kibana (ELK). Vi har flere prosjekter som bruker ELK som logg-aggregator og har god erfaring med disse produktene.","id":61,"levelFactor":0.31125962871440177,"levelId":21,"name":"Logg-aggregering","number":48,"sectorFactor":0.090334470601733163,"sectorId":23,"shape":"circle","size":0},{"description":"Public PaaS og IaaS er trygge valg dersom man ønsker å bruke skytjenester i dag. Leverandører som Microsoft Azure, Heroku og Amazon AWS, er modne og har gjennom mange år vist at de leverer sikre og tilgjengelige løsninger. Vi har brukt disse leverandørene med suksess og har flere prosjekter kjørende på Public PaaS. \u000a\u000aSkytjenester gjør det enkelt å automatisere installasjon og konfigurasjon og gir fleksibilitet rundt opp- og nedskalering. Den største fordelen med public fremfor private er at man slipper en større investering i infrastruktur og at man får større fleksibilitet. Det tilbys også mange tjenester som gir god verdi. \u000a\u000aEn utfordring kan være usikkerheten rundt å plassere sine data utenfor sitt eget datasenter. Så lenge man holder seg innenfor lovverket og evaluerer leverandøren godt, ser vi få problemer med dette.","id":62,"levelFactor":0.54629019299835269,"levelId":21,"name":"Public cloud","number":49,"sectorFactor":0.10064320142908505,"sectorId":23,"shape":"circle","size":0},{"description":"Tradisjonelt har man behandlet store datamengder gjennom batch-kjøringer. Man importerer data for deretter å analysere de, eller man gjør begge deler i samme operasjon. Dette er tunge jobber som krever mye minne og tar lang tid.\u000a\u000aEn annen måte å angripe denne utfordringen på er å benytte streaming. Avhengig av bruksområde kan dette løses på ulike måter. Import og tildels analyse kan kjøres som agenter, som f.eks. i Akka. Agenter muliggjør stor samtidighet og høy ytelse. Dette har vi god erfaring med gjennom flere prosjekter.\u000a\u000aAnalyse kan også løses gjennom streaming. Utfordringen er at nøyaktigheten ofte ikke blir like god som i batch-kjøringer. Dette kan man løse ved å benytte en kombinasjon av streaming og batch. En streaming-løsning som gir resultater basert på oppdaterte data, og en batch-løsning som gir nøyaktige resultater basert på gamle data.\u000a\u000aVi anbefaler Akka, Apache Storm eller Spark Streaming, evt Apache Samza dersom du har bruk for de egenskapene dette gir.","id":63,"levelFactor":0.37004576945401491,"levelId":20,"name":"Streaming arkitektur","number":50,"sectorFactor":0.25071235214805793,"sectorId":23,"shape":"circle","size":0},{"description":"Typesafe Config er et populært bibliotek for håndtering av konfigurasjonsfiler på JVM-en. Det støtter tre formater: Java properties, json og et mer lesbart json-supersett kalt Human-Optimized Config Object Notation (HOCON). Biblioteket er lite, raskt og fleksibelt med et API basert på immutable, trådsikre konfigobjekter. Det har god støtte for konvertering av datatyper, håndtering av overstyrte verdier og gjør det mulig å konfigurere en hel applikasjon, inkludert avhengigheter, fra samme fil. Biblioteket brukes av kjente rammeverk som AKKA, Play og Gatling.\u000a\u000aTypesafe Config bør vurderes for applikasjoner med mer enn trivielle behov for konfigurasjon. Det er spesielt nyttig hvis man skal håndtere mer komplekse konfigurasjonsfiler. For eksempel når man har konfigurasjon for flere miljøer i samme fil.","id":64,"levelFactor":0.24982034618469592,"levelId":20,"name":"Typesafe config","number":51,"sectorFactor":0.098518622712714,"sectorId":24,"shape":"circle","size":0},{"description":"Arkitekturen til de fleste databasene som brukes kommer fra en tid der lagringsplass og minne var veldig dyrt. Disse gamle restriksjonene påvirker fortsatt i stor grad hvordan vi utvikler og designer applikasjoner. Prisen av disk og minne er en liten brøkdel av det det engang var. Likevel er måten vi lagrer data på i stor grad den samme. \u000a\u000aDatomic ble introdusert i 2012 og har en fundamentalt forskjellig måte å tenke på data enn tradisjonelle databaser. I Datomic er all data immutable, noe som betyr at de ikke kan endres. Klientene mellomlagrer også dataene lokalt i hver applikasjon, noe som gjør at spørringene kjøres lokalt på applikasjonene og ikke nødvendigvis tilfører last til lagringsbackenden.\u000a\u000aI Datomic vil man alltid legge til nye fakta og aldri endre eller slette det som allerede finnes. Immutability fører i mange tilfeller til sikrere og mer vedlikeholdbare applikasjoner og disse har nå kommet til databaseverden med Datomic. Immutable egenskaper, kombinert med et kraftig spørrespråk, gjør Datomic til en database som i høyeste grad bør vurderes.","id":65,"levelFactor":0.80145861708048161,"levelId":20,"name":"Datomic","number":52,"sectorFactor":0.62884263538218865,"sectorId":23,"shape":"circle","size":0},{"description":"I en arkitektur hvor applikasjoner er avhengige av kontinuerlig kommunikasjon med hverandre kan ustabilitet i ett ledd fort forplante seg til mange ledd. Hystrix er et rammeverk utviklet av Netflix, som hjelper deg å unngå ytterligere belastning av tjenester som sliter, overvåke status, og realisere ulike fallback-strategier. Feil blir isolert i arkitekturen, noe som reduserer risikoen for forplantning av feil. I tillegg tilbyr Hystrix et godt monitorerings-dashboard ut av boksen.\u000a\u000aTankegangen med automatiske circuit breakers, isolering av feil og fallback-strategier er god å ta med inn i arkitekturen uansett om man benytter Hystrix til dette eller ikke.","id":66,"levelFactor":0.807815635506438,"levelId":20,"name":"Hystrix","number":53,"sectorFactor":0.28246827604457059,"sectorId":24,"shape":"circle","size":0},{"description":"Functional Reactive Programming (FRP) henter det beste fra funksjonell, event-drevet og deklarativ programmering. Dette bør vurderes som en teknikk i GUI-intensive applikasjoner hvor man må reagere på handlinger eller aggregere kompositter av hendelser.\u000a\u000aI FRP vil en strøm av hendelser (datatyper med verdier avhengig av tid) kunne behandles som sekvenser med funksjonell kode som implementerer de ønskede resultatene. Fordelene er blant annet fokus på deklarativitet, rask respons for brukeren, gode muligheter for kompositter\/DRY og kode som er enklere å analysere. Nye (compile-to-Javascript) programmeringsspråk som Flapjax\/Elm baserer seg på denne teknikken, men det finnes også JS-implementasjoner som Bacon.js. Det finnes også gode muligheter for reaktiv programmering i C# og Java med f.eks Reactive Extensions som tillater propagering av datatyper og gjør at en kan designe hendelsesdrevne og responsive applikasjoner som skalerer.","id":67,"levelFactor":0.46488439453408859,"levelId":20,"name":"Functional reactive programming","number":54,"sectorFactor":0.85710229934339421,"sectorId":24,"shape":"circle","size":0},{"description":"Go er et programmeringsspråk som er laget av Google, og har fokus på enkelhet, stabilitet og ytelse. Go kompilerer direkte til maskinkode, og språket prøver på mange måter å være en konkurrent til mer tradisjonelle systemspråk som C og C++. Videre har språket flere interessante egenskaper som garbage collection, ingen dynamiske avhengigheter, et rikt standardbibliotek og god dokumentasjon.\u000a\u000aGo er statisk typet, men ved å støtte Duck-typing og automatisk typeinferens, føles språket nesten som et dynamisk språk. Språket sin modell for concurrency er spesielt interessant, en modell hvor «prosesser» sender meldinger til hverandre over kanaler,  inspirert av Communicating sequential processes, beskrevet av Tony Hoare. Denne modellen gjør språket spesielt egnet til bruk i distribuerte systemer, og et språk som vi mener det er viktig å ha i verktøykassen i dagens IT-løsninger hvor mikrotjenester, skrevet i ulike programmeringsspråk avhengig av behov, blir mer og mer brukt. Go brukes i dag av store aktører som Heroku, Github og Google. BEKK har i dag ingen prosjekter som bruker Go, men det er absolutt et språk vi mener det er verdt å vurdere.","id":68,"levelFactor":0.29625216361576812,"levelId":20,"name":"Go","number":55,"sectorFactor":0.694454014099476,"sectorId":24,"shape":"circle","size":0},{"description":"I likhet med Dropwizard er Spring Boot et lite rammeverk som raskt lar deg komme i gang med Java-applikasjoner ved å samle et sett med rammeverk og bibliotek i et ferdig oppsett. Spring følger med på lasset, men har du allikevel tenkt å bruke Spring vil Spring Boot gjøre det enkelt for deg. Du kan velge mellom servere som Jetty, Tomcat og Undertow. Metrics, databasetilkobling, helsesjekk og kommandolinjeverktøy følger også med, for å nevne noen. Fra og med Spring Boot 1.2 får du også med Jersey, som gir JAX-RS-støtte, og det liker vi godt.\u000a\u000aHvis du trekker inn en avhengighet du ikke har konfigurert kan Spring Boot autokonfigurere den, vel å merke dersom du har tillat det med å bruke @EnableAutoConfiguration-annotasjonen. Du kan fri deg fra de automatiske avhengighetene etterhvert. Spring Boot viker raskt unna om utvikleren overstyrer, og på den måten kan man begynne med avhengighetene Spring Boot gir, men gradvis gå over til et skreddersydd oppsett.\u000a\u000aKoblingen til Spring gjør at vi sier Vurdér. I mange prosjekter gir lettvektere som Guice deg det du trenger og bør vurderes.","id":69,"levelFactor":0.32887781578569414,"levelId":20,"name":"Spring Boot","number":56,"sectorFactor":0.51299043697674929,"sectorId":24,"shape":"circle","size":0},{"description":"Clojure er en dynamisk typet, funksjonell LISP-dialekt som kompilerer direkte til JVM-bytekode. Med økende krav til parallellisering og derigjennom et ønske om å skrive funksjonell kode, har Clojure blitt et utbredt og akseptert alternativ på JVM-en. Clojure har veldig god interoperabilitet med Java, og gjør det mulig å skrive konsis funksjonell kode både for backend og frontend.\u000a\u000aEn rekke store selskaper og produkter bruker Clojure i dag, blant annet Prismatc, Datomic, Trend Micro, Puppet Labs, Citigroup, Netflix og Walmart mobile. Clojure er et språk vi har tro på og som vil kunne være aktuelt for de rette prosjektene. Det er dog viktig for disse prosjektene å vurdere tilgangen på Clojure-kompetansen i det norske markedet før man starter opp.","id":70,"levelFactor":0.83133328382082639,"levelId":20,"name":"Clojure","number":57,"sectorFactor":0.7711767753299027,"sectorId":24,"shape":"circle","size":0},{"description":"Er du lei av å skyte spurv med Hibernate, men ønsker deg fortsatt fordelen av objekt-mapping og abstraksjon mot databaselaget? Da kan det hende du burde vurdere et Mikro-ORM. \u000a\u000aDet finnes en rekke produkter som er mye lettere enn de tradisjonelle ORM-ene. Mikro-ORM-ene tar på seg jobben med å oversette mellom databaselaget og objektmodellen. Funksjonaliteten varierer, men det er vanlig at de skåner deg fra å skrive kode som henter ut data rad for rad. Du får fortsatt gleden av å skrive din egen SQL. \u000a\u000aPå denne måten får man mer kontroll, og mindre av magien, konfigurasjonen og de uforklarlige, gjemte feilene som pleide å holde oss våkne om natten i ORM-tiden.","id":71,"levelFactor":0.36082152495340147,"levelId":20,"name":"Mikro-ORM","number":58,"sectorFactor":0.29038969067635673,"sectorId":24,"shape":"circle","size":0},{"description":"Swift er et kraftig og intuitivt programmeringsspråk som brukes ved utvikling av programvare på iOS og OSX plattformer. Språket er laget av Apple og er etterkommeren til Objective-C. Swift er et objektorientert språk og man bruker det integrerte utviklingsmiljøet Xcode som kan gi status og tilbakemeldinger i sanntid. Samtidig har Swift avansert typesjekking, noe som ofte gjør det enklere å utvikle og vedlikeholde apper. \u000a\u000aSwift henter inspirasjon fra andre språk som f.eks. Rust, Haskell, Ruby, Python, C#, CLU og Objective-C, og utnytter kompilator-verktøyet LLVM til rask generering av effektiv native kode. Swift kan brukes side om side med Objective-C, og begge språk kan integreres i samme prosjekt. \u000a\u000aI Apple-sammenheng skal Swift overta for Objective-C, og siden lanseringen i 2014 har språket blitt positivt mottatt og er allerede meget populært. Swift har blitt brukt på flere kundeprosjekter i BEKK.","id":72,"levelFactor":0.11561874315718172,"levelId":21,"name":"Swift","number":59,"sectorFactor":0.91561507368231743,"sectorId":24,"shape":"circle","size":0},{"description":"Neste versjon av ASP.NET MVC er en fusjon av Web API og MVC til et felles rammeverk. Neste versjon er snart ute, så om man starter nye webprosjekter så anbefaler vi at man benytter denne versjonen. Dersom man ikke har anledning til dette så er det bedre å bli på de versjonene som har support i dag.\u000a\u000aEn ny feature som man absolutt bør vurdere hvis man kan gå for neste versjon av ASP.NET MVC er å benytte seg av Core CLR som skal være et \"cloud-optimized runtime\". Med dette får man et minimalt sett med avhengigheter og kan kjøre applikasjoner på forskjellige versjoner av .NET - noe som er en stor fordel i en organisasjon med flere applikasjoner.","id":73,"levelFactor":0.14037647435884887,"levelId":21,"name":"ASP.net MVC","number":60,"sectorFactor":0.71128477120905265,"sectorId":24,"shape":"circle","size":0},{"description":"Akka gir deg Actors på Java plattform. Actors er et programmeringsparadigme som ble kjent via språket Erlang og som blant annet gir god støtte for asynkronitet, robusthet og concurrency.\u000a\u000aActors kan kort sies å være innkapslinger av tilstand i enheter som gjør meldingsutveksling og som har en eksplisitt og detaljert livssyklus-håndtering.\u000a\u000aAkkas API fungerer meget godt sammen med Java eller Scala, og kan spesielt anbefales dersom man har standardisert på Java og ikke kan bruke Scala men har mulighet til å kjøre på Java 8. Det finnes også en .NET-implementasjon av APIet.\u000a\u000aOm man har erfaring fra klassisk objekt-orientering kan det ta litt tid å komme ordentlig inn i asynkronitet og bruk av actor-hierarkier. Måten man må utvikle på endrer seg en del, og det å bruke konseptene slik at man utnytter - og ikke motarbeider - rammeverket krever litt trening.\u000a\u000aI BEKK brukes Akka i en hel del prosjekter, og vi har gode erfaringer med hvordan ytelse, skalerbarhet og robusthet har blitt - også i tildels komplekse clustrede applikasjoner.","id":74,"levelFactor":0.67318884332047746,"levelId":21,"name":"Akka","number":61,"sectorFactor":0.76715803632630952,"sectorId":24,"shape":"circle","size":0},{"description":"Funksjonell programmering får nå fotfeste, også på tradisjonelle plattformer og kjøretidsmiljøer som Java og .NET.\u000a\u000aSom for andre paradigmeskifter kan overgangen fra klassisk imperativ og\/eller objekt-orientert programmering være ressurs- og tidkrevende. Imidlertid kan man prøve å gjøre overgangen mer gradvis dersom verktøyene man har til rådighet åpner for det. Eksempelvis ser vi klare trekk fra funksjonell tankegang og programmeringsstil i ren Java på Java 8, og Scala tilbyr mange konsepter fra funksjonell programmering. Rene funksjonelle språk er også tilgjengelige på utbredte kjøretidsmiljøer, se egne punkter for Clojure og F#.\u000a\u000aFunksjonell programmering har eksistert en lang stund men har ikke fått stor utbredelse i industrien. Vi mener at dagens rammebetingelser for effektiv prosessering kan endre dette: God parallellitet er nå viktigere for å sikre skalerbarhet enn god single-thread ytelse. Og immutabilitet, en helt grunnleggende egenskap i funksjonell programmering, senker terskelen for å oppnå effektiv og feilfri parallellisering.","id":75,"levelFactor":0.67164423688907715,"levelId":21,"name":"Funksjonell programmering","number":62,"sectorFactor":0.27264142751753107,"sectorId":24,"shape":"circle","size":0},{"description":"F# er et \"functional first\" programmeringsspråk for .NET CLR. Med F# skriver man først og fremst funksjonell kode, men man kan også bruke elementer av objektorientert programmering hvis man ønsker det. \u000a\u000aFunksjonell kode gir færre sideeffekter og tilbyr immutable datastrukturer og komponering som et mer elegant alternativ til arv. Man får også sterkere typing og mer avanserte datatyper - eksempelvis discriminated unions. \u000a\u000aSom språk og verktøy er F# såpass modent, og har så sterk backing fra Microsoft, at vi kan anbefale å ta det i bruk. Samtidig ønsker vi å påpeke at det er en viss terskel forbundet med å lære seg nye programmeringsparadigmer, og tilgangen på kompetanse på F# i markedet kan være litt mangelfull nå. Dette kan dog endre seg, da interessen for F# ser ut til å vokse.\u000a\u000aNår man har lært seg F# vil man ofte se at koden bli mer lesbar, enklere å vedlikeholde og også enklere å skalere.","id":76,"levelFactor":0.43446814623888319,"levelId":21,"name":"F#","number":63,"sectorFactor":0.1701424262311812,"sectorId":24,"shape":"circle","size":0},{"description":"Implementasjon av mekanismer som håndterer passord, kryptering eller beskytter mot \"Cross Site Scripting\", er ofte mye vanskeligere enn man tror. Eksempelvis finnes det på StackOverflow store mengder aksepterte svar som er direkte feil. Innen sikkerhet bør man derfor velge rammeverk som er godt testet og bruker mekanismene på riktig måte. \u000a\u000aSpring Security er et modent Java-rammeverk for autentisering og autorisering. For enklere eller mindre løsninger, kan Apache Shiro være et godt alternativ. Apache Shiro er et Java-rammeverk som håndterer autentisering, autorisering, sesjonshåndtering og kryptering. Det har god støtte for tilleggsfunksjonalitet en vanligvis ikke finner i slike rammeverk, som korrekt caching av bruker-objekter og \"husk meg\"-støtte ved innlogging. \u000a\u000aOWASP AntiSamy gjør det mulig å la brukere publisere HTML uten at det utsetter applikasjonen for XSS-sårbarheter. Det er viktig at Antisamy-policyen er restriktiv. Jo åpnere policyen er, jo større risiko har en for å introdusere hull som gjør at en ondsinnet bruker kan injisere kjørbar kode. \u000a\u000aBEKK benytter denne type rammeverk i de fleste av våre prosjekter.","id":77,"levelFactor":0.1043432321991089,"levelId":21,"name":"Sikkerhetsrammverk","number":64,"sectorFactor":0.10665447853935328,"sectorId":24,"shape":"circle","size":0},{"description":"Dropwizard er et lite rammeverk som lar deg komme igang med Java-applikasjoner med REST raskt. Dropwizard tar en del gode valg for deg og setter opp Jetty med Jersey, Jackson, logback, liquibase, monitorering og helsesjekk, for å nevne noe. Avhengighetsinnsprøytning (dependency injection) følger ikke med, men et vanlig valg er å legge inn lettvektsvarianten Guice fra Google.\u000a\u000aDropwizard genererer ikke kode for deg, men er en tynn wrapper rundt Jetty. Det betyr at du vil være avhengig av at Dropwizard blir oppdatert når nye versjoner av Jetty, Jersey etc blir lansert. Vi sier likevel Bruk da det er fornuftige valg som er tatt, wrapperen er tynn og fleksibiliteten er god nok for de fleste. Hvis du har andre behov er det nok lurt å skrive sin egen variant. I så fall går det jo an å la seg inspirere av hvordan de har gjort det hos Dropwizard.","id":78,"levelFactor":0.44242743541018048,"levelId":21,"name":"Dropwizard","number":65,"sectorFactor":0.83505053242129079,"sectorId":24,"shape":"circle","size":0},{"description":"Hvis du bruker en database og har høye krav til pålitelighet og oppetid har du sannsynligvis bruk for en JDBC connection pool. BoneCP har lenge vært det foretrukne valget til JVM - dette til en viss grad på grunn av mangel på gode alternativer. Nå har HikariCP kommet på banen og seiler opp som den beste løsningen. Det er lite (70Kb), pålitelig og raskt. Vi tar det i bruk i flere og flere prosjekter og har gode erfaringer. Enkelte sier det kan være vanskelig å sette opp, men samtidig har HikariCP mange gode defaults som fører til at konfigurasjonen blir liten. \u000a\u000aI bruk løser HikariCP en del av de gamle utfordringene til BoneCP. Hikari har for eksempel mer pålitelig feilhåndtering, noe som kan føre til færre problemer og flere friske kobilinger dersom man har en ustabil kobling mot databasen.","id":79,"levelFactor":0.08931031123338215,"levelId":21,"name":"HikariCP","number":66,"sectorFactor":0.42600880815403558,"sectorId":24,"shape":"circle","size":0},{"description":"De store ESB-enes tid er på hell, men behovet for integrasjon er her fortsatt. I BEKK har vi gode erfaringer med å bruke lettvekts integrasjonsrammeverk, som Apache Camel.\u000a\u000aSlike rammeverk er kjennetegnet av få avhengigheter, god testbarhet og klart definerte oppgaver som løses på en god måte.","id":80,"levelFactor":0.1019924229909524,"levelId":21,"name":"Lettvekts Integrasjonsrammeverk","number":67,"sectorFactor":0.270456554852139,"sectorId":24,"shape":"circle","size":0},{"description":"RxJava er et lite, open-source bibliotek for å bygge hendelsesdrevne, parallelle og asynkrone programmer på JVM. Biblioteket er Reactive Extensions(Rx) implementert for JVM (http:\/\/reactivex.io\/).\u000a\u000aRx gir deg nyttige verktøy så du kan forholde deg til \"infinite streams of bursting data\" på en sømløs måte, uten å la datastrømmene gå over sine bredder og uten at sikringer går i utviklerhjernene. En bruker av et Rx-API trenger ikke vite om en operasjon er synkron eller asynkron - man gjør kallet på samme måte uansett. RxJava anbefales for alle som skal tilgjengeliggjøre et Java API. Rammeverket støtter mange forskjellige JVM-språk - slik at man enkelt kan integrere tjenester på tvers av språk.","id":81,"levelFactor":0.32589395666133425,"levelId":21,"name":"RxJava","number":68,"sectorFactor":0.39985328493730304,"sectorId":24,"shape":"circle","size":0},{"description":"Scala er en hybrid av funksjonelt og objektorientert språk som kjører på JVM-en. Med et avansert typesystem og kompilering direkte til JVM-\"bytecode\", tilbyr Scala både konsis syntaks, vanligvis forbundet med dynamiske språk, og kjøretidsytelse på høyde med Java eller bedre.\u000a\u000aScala har i de siste årene blitt et av de aller mest populære alternative språkene på JVM-en og brukes i store forretningskritiske systemer hos bl.a. LinkedIn, Twitter og The Guardian. Scala har lav terskel for Java-utviklere og avansert IDE-støtte i både Eclipse og IntelliJ. I BEKK bruker vi Scala i flere kundeprosjekter i kombinasjon med og Lift, Play Framework, Scalatra og Akka. Scala kan tas inn i eksisterende utviklingsmiljø, rulles ut på eksisterende Java-infrastruktur og er et reelt alternativ til Java. Selv med Java 8 tilgjengelig vil Scala være attraktivt. Med bedre støtte for funksjonell programmering og mer avansert typesjekking vil man kunne skrive mer konsis kode som er enklere å vedlikeholde.","id":82,"levelFactor":0.86613293423319282,"levelId":21,"name":"Scala","number":69,"sectorFactor":0.43437620984699438,"sectorId":24,"shape":"circle","size":0},{"description":"JooQ er et eksempel på ett av flere domenespesifikke språk for SQL som er laget. JooQ skiller seg ut ved at det er en av de mer modne. Å bruke objekt-relasjonell-mapping (ORM) kan fungere bra i mange tilfeller, men veldig ofte må man uansett skrive SQL. Hvorfor ikke droppe abstraksjonen som denne mappingen gir og skrive ren SQL i ditt språk?\u000a\u000aJooQ bruker kodegenerering fra databaseskjema og den genererte DSL-en støtter et bredt spekter av SQL-dialekter. Oppsiden er at du får tilbakemelding i kompilering av din SQL, typesikre verdier og SQL-injeksjoner blir en historisk problemstilling.","id":83,"levelFactor":0.10039738163276636,"levelId":21,"name":"JooQ (SQL i java)","number":70,"sectorFactor":0.56183443149901835,"sectorId":24,"shape":"circle","size":0},{"description":"React er laget av Facebook, og har vokst raskt i popularitet gjennom det foregående året. Biblioteket brukes for å utvikle brukergrensesnittet i javascript-applikasjoner, gjerne som V-en i et MVC-rammeverk, eller med Flux-arkitekturen til Facebook. \u000a\u000aI motsetning til større js-rammeverk som Angular kan React tas i bruk på deler av applikasjonen, uten å kreve at hele applikasjonen benytter seg av React. Med React bygger man små gjenbrukbare komponenter med en deklarativ tilnærming - en uttrykker hvordan applikasjonen skal se ut, heller enn hvilke DOM-operasjoner som er nødvendige for å oppnå det man ønsker.\u000a\u000aGjennom å generere midlertidige DOM-noder i JavaScript og benytte en diff-algoritme, kan React beregne om det i det hele tatt trenger å gjøre en endring i DOM-en når data forandrer seg og hva som er den minimale endringen som skal til. Slik sett abstraherer man bort DOM-en og oppnår samtidig svært god ytelse.\u000a\u000aDen deklarative tilnærmingen inspirert av funksjonell programmering oppleves som svært nyttig i utviklingen av komplekse grensesnitt.","id":84,"levelFactor":0.53055210653930285,"levelId":21,"name":"React","number":71,"sectorFactor":0.80343455977740774,"sectorId":25,"shape":"circle","size":0},{"description":"ES6 (endrer navn til ES2015) er neste iterasjon av ECMAScript-standarden som JavaScript er en implementasjon av. Standarden er i Release Candidate form nå og det finnes primært tre kategorier av nye features: Syntaktisk sukker, nye API-er og nye språkkonstruksjoner. Nye API-er (f.eks Promises) har alt vært brukt via biblioteker og polyfills en stund.\u000a\u000aSyntaktisk sukker, eksempelvis destructuring og fat-arrows kan trygt tas i bruk da det finnes gode verktøy for å konvertere dette til standard ES5-kompatibel kode (f.eks Babel), i tillegg til at flere nye nettlesere allerede har innebygget støtte for dette.\u000a\u000aSpråkendringer som Map\/Set\/WeakMap\/WeakSet, generators\/iterators, symboler og tail-call recursion, er mer usikre, da disse krever store runtimes for å kjøre og ikke alle har gode implementasjoner. Kostnaden kan være for stor for utbyttet og bruk av disse bør derfor vurderes nøye.\u000a","id":85,"levelFactor":0.35614846199401756,"levelId":20,"name":"ES6","number":72,"sectorFactor":0.67619972587791544,"sectorId":25,"shape":"circle","size":0},{"description":"Universal apps for Windows er apper man utvikler en gang, men kan kjøre på både Windows Phone og Windows 8. Man kan bruke XAML, HTML og DirectX sammen med programmeringsspråkene C++, C# eller JavaScript for å utvikle universal apps. I tillegg kan man velge om deler eller all kode skal deles mellom telefoner og datamaskiner\/tablets. Hvis en kjøper en applikasjon på telefon kan man velge at kunden også får bruke applikasjonen på datamaskin\/tablet uten ekstra kostnad.\u000a\u000aUniversal apps blir utviklet på Windows med Visual Studio 2013 eller nyere. For organisasjoner som bruker Windows-teknologier så kan universal apps være en enkel måte å implementere forretningsapplikasjoner som kan kjøres på en datamaskin\/tablet eller i en telefon.\u000a","id":86,"levelFactor":0.29631643054023116,"levelId":20,"name":"Universal apps","number":73,"sectorFactor":0.49722002576511237,"sectorId":25,"shape":"circle","size":0},{"description":"Less og Sass er preprosessorer til CSS som beriker språket med ny funksjonalitet: Nøsting, variabler, mixins, funksjoner m.m. Dette kompileres ned til ren CSS med en JS-kompilator. Noe av funksjonaliteten som kommer med Less og Sass er idag på tur inn som egne webstandarder, men mesteparten er et stykke unna\u000a\u000aBruken av Less og Sass bør forutsette at man har en klar plan for hvorfor man ønsker å bruke dem. Vi opplever at CSS-kodebaser kan ende opp med å bli mer komplekse og noe mindre forvaltbare etter innføring av Less eller Sass. Dette gjelder spesielt unødvendig nøsting, som fører til i overkant spesifikke selektorer som igjen fører til lite gjenbrukbare stilregler.\u000a\u000aCSS-preprosessorer hjelper deg å gjøre god CSS bedre - den hjelper deg ikke nødvendigvis å skrive god CSS. Derfor bør disse ikke være en defacto standard på ethvert nytt prosjekt, men bruken bør derimot vurderes opp mot CSS-kompetansen i teamet og prosjektets behov.\u000a","id":87,"levelFactor":0.37313890792425591,"levelId":20,"name":"Less og Sass","number":74,"sectorFactor":0.902463828247753,"sectorId":25,"shape":"circle","size":0},{"description":"Angular har vært et svært populært JavaScript-rammeverk de siste årene. Rammeverket er laget av Google, og er til en viss grad inspirert av Java-verdenen og benytter seg blant annet av IoC-mekanismer. Sammenlignet med for eksempel Backbone og React er det et langt større rammeverk målt i omfang.\u000a\u000aDet siste året har Angular vært i hardt vær og fått kritikk fra flere hold. Mange hevder at Angular er uhensiktsmessig stort i omfang, er vanskelig å forstå for nybegynnere og har dårlig ytelse på større prosjekter. Noen føler at de i større grad skriver Angular-kode enn JavaScript-kode, og at det blir svært vanskelig dersom man skal gjøre noe som rammeverket ikke støtter. Til sist er det også varslet at versjon 2 av Angular ikke er bakoverkompatibel med Angular 1 (men vi ser at det er noen småting på gang for å hjelpe overgangen). Alt dette tatt i betraktning er det vanskelig å skulle anbefale bruk av Angular på nye prosjekter.\u000a\u000aNår dette er sagt, er Angular brukt med hell på flere av våre prosjekter og har helt klart en plass i JavaScript-land, kanskje spesielt i mindre, prototype-baserte prosjekter. Vi venter i spenning på flere detaljer rundt Angular 2.0, som blant annet har hentet inn tilnærmingen med en virtuell DOM fra React.\u000a","id":88,"levelFactor":0.61340541956960315,"levelId":20,"name":"Angular","number":75,"sectorFactor":0.31064431115232516,"sectorId":25,"shape":"circle","size":0},{"description":"iBeacon er et posisjoneringssystem laget av Apple. Med små enheter og lavenergi blåtann kan de gi finkornet områdeinformasjon til applikasjoner. Bruksområdet er fortrinnsvis mobiltelefoner og iBeacons gir på en enkel måte en applikasjon på telefonen veldig presis opplysning om hvor du er. Applikasjonen kan da gi deg kontekstuell informasjon, samtidig som applikasjonen også kan sende informasjon tilbake til en server slik at området brukeren befinner seg i kan forandre seg sett fra brukerens ståsted.\u000a\u000aVi i BEKK tror vi vil se mer av iBeacons i tida som kommer. Det er dog større spenning knyttet til om forbrukerene vil akseptere mer \"overvåkning\". For at dette skal bli en suksess er man avhengig av at forbrukerene får noen skikkelige fordeler ut av å bruke dette. Et annet bruksområde som kan være spennende er hjemme-automasjon. Man kan bruke iBeacons til å styre lys, temperatur og lignende på bakgrunn av hvordan beboere beveger seg i hjemmet.\u000a","id":89,"levelFactor":0.64950376913721675,"levelId":20,"name":"iBeacons","number":76,"sectorFactor":0.14640703838185112,"sectorId":25,"shape":"circle","size":0},{"description":"Web Components lar oss bygge innkapslede og gjenbrukbare komponenter (widgets) med standard webteknologi. Dette gjøres ved hjelp av egendefinerte HTML-elementer, Shadow DOM for å innkapsle HTML, styling og JavaScript, og HTML imports for å importere dine egne eller andres moduler. Standarden er under arbeid, men støttes allerede av de fleste nyere browsere og flere polyfill-bibliotek finnes (det største er Polymer fra Google og gir ekstra funksjonalitet). Flere større rammeverk går i retning av Web Components, inkludert Angular og Ember.\u000a\u000aVi ser at det kan bli utfordrende med versjonering og avhengigheter dersom du har mange moduler med komponenter. Som alltid er det fornuftig å starte i det små, med noen få komponenter, frem til man har fått på plass rutiner for release, versjonering og integrasjonstesting. Som alltid med gjenbruk er det vanskelig\/uhensiktsmessig å designe for gjenbruk før gjenbruket faktisk er aktuelt. En strategi som har fungert bra for oss har vært å dra ut komponenter fra applikasjoner idet behovet for gjenbruk oppstår i andre applikasjoner.\u000a","id":91,"levelFactor":0.58488295443374572,"levelId":20,"name":"Web Components","number":77,"sectorFactor":0.78138387439311408,"sectorId":25,"shape":"circle","size":0},{"description":"\"Persistent data structures\" og \"immutable objects\" kan gjøre håndtering av tilstand og endringer enklere å forholde seg til. Ideen er enkel; data som er lagt til kan ikke endres. Dette konseptet brukes i LINQ (C#), Streams (Java 8) og funksjonell programmering. I tillegg finnes det biblioteker som Immutable.js (JavaScript) og Mori (ClojureScript). \u000a\u000aGjennom bruk av disse konseptene kan man enklere teste koden og man er sikret mot tilfeldige sideeffekter ved bruk av datastrukturer som parametere til funksjoner. Flere prosjekter i BEKK har gode erfaringer med bruk av disse konseptene.","id":92,"levelFactor":0.61258401026200437,"levelId":20,"name":"Persistent data structures","number":78,"sectorFactor":0.581252881983184,"sectorId":25,"shape":"circle","size":0},{"description":"Et av de sentrale problemene med single-page applikasjoner har vært i hvilken grad søkemotorer kan navigere i dem. Søkemotorer er dessverre fortsatt dårlige på rendring av JavaScript-baserte applikasjoner. I tillegg er rendringen av single-page-applikasjoner avhengig av ytelsen på klienten. Samtidig er verdien av single-page applikasjoner høy, spesielt i interaktive applikasjoner.\u000a\u000aIsomorfe JavaScript-applikasjoner er applikasjoner som håndterer begge disse behovene. En isomorf applikasjon er altså en single-page applikasjon som initielt rendres på backend. Noe som vil skje raskere iom at rendringen kjører på bedre hardware enn det de fleste klienter disponerer. HTML-en sendes til nettleseren, som så tar over kontrollen og fungerer som en vanlig single-page applikasjon.\u000a\u000aDet er fortsatt ikke veldig mye informasjon å finne om isomorfe JavaScript-applikasjoner, men vi ser på dette som svært viktig i applikasjoner som ikke krever innlogging og der det er ønskelig å være tilgjengelig i søkemotorer. Det er på tide å begynne å bygge kompetanse på fagfeltet!\u000a","id":93,"levelFactor":0.41820149930121,"levelId":20,"name":"Isomorfe JavaScript-applikasjoner","number":79,"sectorFactor":0.3982573157854683,"sectorId":25,"shape":"circle","size":0},{"description":"Xamarin for iOS og Android lar utviklere lage apper for Windows 8, iOS og Android i C#\/.NET. Dette åpner for stor grad av gjennbruk av kode på tvers av plattformene, samtidig som resultatet og brukeropplevelsen er 100% native.\u000a\u000aDet er imidlertid viktig å være klar over at Xamarin ikke abstraherer bort konseptene på den underliggende plattformen – man må fortsatt forholde seg til de spesifikke egenskapene plattformen har å by på. Xamarin som plattform har nå eksistert en stund og har med det klart å vise seg som et verdig alternativ til kryss-plattform utvikling.\u000a","id":94,"levelFactor":0.28857273493599589,"levelId":20,"name":"Xamarin","number":80,"sectorFactor":0.21248259479839052,"sectorId":25,"shape":"circle","size":0},{"description":"De siste årene har vi sett stadig nye smarte klær, briller, armbånd og klokker. Spesielt har klokkene sett en oppsving i popularitet. Først gjennom Pebble, så Android wear og nå Apple Watch. Vi tror stadig flere vil eie en smartklokke i tiden fremover og det åpner for enda flere applikasjonsflater som det er verdt å investere kompetansetid i.\u000a\u000aVi er nå tidlig i utviklingen rundt wearables, og vi tror ikke det finnes store muligheter for høy Return on investment på investeringer gjort rundt wearables i Norge for øyeblikket. Det kan dog være verdt å bygge kompetanse på dette, samt lage små prototyper eller stunts som kan vekke oppmerksomhet i markedet. Særlig ser vi spent på mulighetene som finnes rundt helse og aktivitetssporing.\u000a","id":95,"levelFactor":0.38887913637857657,"levelId":20,"name":"Wearables","number":81,"sectorFactor":0.0701492382575254,"sectorId":25,"shape":"circle","size":0},{"description":"WAI-ARIA er en spesifikasjon fra W3C som definerer hvordan applikasjoner og annet nettinnhold i større grad kan gjøres tilgjengelig for de som bruker IKT-hjelpemidler – som for eksempel skjermlesere.\u000a\u000aWAI-ARIA angir et sett attributter som settes på HTML-elementer, og som fungerer som et ekstra lag med beskrivende metadata. Det er ikke ment som en erstatning for semantikken som allerede finnes i HTML, men som et tillegg. Dette er spesielt nyttig i avanserte og dynamiske grensesnitt, og kan for eksempel brukes til å informere skjermleseren om endringer – som at nytt innhold lastes inn eller at aktivering av en knapp fører til skjuling eller ekspandering av mer innhold.\u000a\u000aVi anbefaler å benytte WAI-ARIA på alle nye prosjekter.\u000a","id":96,"levelFactor":0.30160728976844003,"levelId":21,"name":"WAI-ARIA","number":82,"sectorFactor":0.8637247401685727,"sectorId":25,"shape":"circle","size":0},{"description":"Blant package managers for JavaScript har npm helt klart vunnet kampen. I dag er det utenkelig å starte et JavaScript-prosjekt uten en skikkelig package manager, og etter litt frem og tilbake de siste årene sitter vi igjen med helt klart mest positive erfaringer med npm.\u000a\u000aMange tror fortsatt at npm bare inneholder pakker for Node.js, men faktum er at de aller fleste pakker helt fint kan brukes på frontend også. Gode eksempel er blant annet Underscore, lodash og async. Konkurrenter som Bower, Volo og andre er ikke i nærheten når det kommer til antall tilgjengelig pakker\/biblioteker.\u000a\u000aEn av de mest positive erfaringene med npm kommer sammen med verktøy som browserify og webpack. Da har du muligheten til å require pakker i frontend-kode på samme måte som du kan gjøre i Node.js.\u000a\u000aDet bør også nevnes at Nexus nå støtter npm-pakker, både som proxy, og for å eksponere private pakker.\u000a","id":97,"levelFactor":0.15782212554975383,"levelId":21,"name":"npm","number":83,"sectorFactor":0.67385586818515453,"sectorId":25,"shape":"circle","size":0},{"description":"Med WebSockets kan vi opprette en toveis kobling mellom nettleser og server. Dette gjør at vi blant annet kan sende data fra serveren til nettleseren idet data endres. Vi har sett at WebSockets kan muliggjøre en rekke nye features, og ettersom IE10 nå har fått full støtte for WebSockets, er denne funksjonaliteten kompatibel med alle vanlige nettleser. Vi har stor tro på WebSockets og bruker det på flere prosjekter.\u000a\u000aInfrastrukturen mellom ytre brannmur og applikasjonsserver kan i noen tilfeller utløse problemer ved bruk av WebSockets, spesielt oppsett av reverse proxy eller selve applikasjonsserveren. Feil eller manglende støtte her kan bli omfattende å feilsøke. Så undersøk hvordan WebSockets fungerer på ditt prosjekt før du baserer deg for mye på teknologien.\u000a\u000aDersom man kun trenger å sende data fra server til klient, og ikke er avhengig av støtte for Internet Explorer, kan Server-Sent Events være et godt alternativ.\u000a","id":98,"levelFactor":0.17475041065898081,"levelId":21,"name":"WebSockets og Server-Sent Events","number":84,"sectorFactor":0.42877631355540985,"sectorId":25,"shape":"circle","size":0},{"description":"Skriv frontend-kode som om det var Node.js-kode. Det kan høres rart ut til å begynne med, men erfaringen med disse verktøyene er at ting blir mye enklere når man behandler frontend-koden på samme måte som vi behandler backend-koden. Altså: flere små moduler istedenfor svære enkeltfiler samt mindre knytning til DOM-en gjør at det blir mye enklere å vedlikeholde og utvide.\u000a\u000aDet er filosofiske forskjeller på disse verktøyene, og den primære er at browserify er en minimal løsning som fokuserer på å gi deg Node.js sin require og håndterer ekstra features gjennom plugins og transforms, mens webpack en en full-featured løsning som ut av boksen blant annet gir deg watching av filer, støtte for AMD i tillegg til CommonJS, og mulighet til å require CoffeeScript og andre typer filer.\u000a\u000aEn fantastisk feature i webpack vi har lyst til å trekke frem er muligheten for å gjøre \"Hot Module Replacement\". Dermed kan man skrive kode, lagre filen, og se endringen bli lagt til på frontend uten å gjøre en refresh. Det finnes blant annet en versjon for React, som gjør at man kan få \"hot reloading\" av React-komponenter.\u000a","id":99,"levelFactor":0.44265962525735536,"levelId":21,"name":"browserify og webpack","number":85,"sectorFactor":0.55111218864266553,"sectorId":25,"shape":"circle","size":0},{"description":"Alle JavaScript-applikasjoner må idag gjennom et byggetrinn, enten det bare er for å minifisere koden eller om det er større oppgaver, som for eksempel å transpilere TypeScript eller ES6, kjøre tester eller linte koden. Det har kommet en rekke verktøy de siste årene, hvorav de mest kjente er Grunt og Gulp. Vi har hatt positive erfaringer med begge.\u000a\u000aVi mener et viktig poeng er å kjøre koden under utvikling så nært som mulig til slik den vil kjøres i produksjon. Med watching av fil-endringer i byggeprosessen er det relativt smertefritt å kontinuerlig bygge en fil som ser lik ut i utvikling og produksjon, slik at du kan føle deg sikker mens du utvikler. En annen mulighet for watching er å kjøre testene hver gang du gjør kode-endringer. Da kan du kontinuerlig se status på testene.\u000a\u000aSamtidig vil vi påpeke at det er viktig å holde byggetrinnet enkelt, så det ikke blir for mye magi.\u000a\u000aVi anbefaler å bruke JavaScript-baserte verktøy til bygging av JavaScript-applikasjoner, altså verktøy som kan kjøres fra Node.js eller io.js. For å få JavaScript-byggingen inn som en del av byggesteget for resten av applikasjonen din, finnes det i dag flere gode alternativer. Ett alternativ vi har brukt med stor suksess på flere prosjekter er frontend-maven-plugin.\u000a","id":100,"levelFactor":0.31698039749762291,"levelId":21,"name":"Byggetrinn for frontend","number":86,"sectorFactor":0.19418541567856049,"sectorId":25,"shape":"circle","size":0},{"description":"Mobile hybridapplikasjoner gir deg flere av fordelene fra begge leirene: Write once run everywhere fra web; ytelse, konvensjoner og støtte for bruk av ekstrautstyr på telefonen fra native. Ulempen er at du må håndtere overgangen mellom web og native med de utfordringene det innebærer. Dette er definitivt ingen gratis lunsj; man vil typisk møte utfordringer med caching, sidelasting og god brukeropplevelse i både webgrensesnitt og native kode.\u000a\u000aVi har laget hybridapplikasjoner for kunder med stort hell, men ikke undervurder mengden tilpasning som må gjøres for å få det bra!","id":101,"levelFactor":0.66922312817245011,"levelId":21,"name":"Hybrid-app","number":87,"sectorFactor":0.41016214287461722,"sectorId":25,"shape":"circle","size":0}],"published":"True","sectors":[{"id":22,"index":0,"name":"Prosess og kvalitet"},{"id":23,"index":1,"name":"Arkitektur og plattform"},{"id":24,"index":2,"name":"Språk og rammeverk"},{"id":25,"index":3,"name":"Frontend og mobil"}],"startDate":"\/Date(1430172000000+0200)\/","updateDate":"\/Date(1433621169763+0200)\/","url":"techradar2015"}
