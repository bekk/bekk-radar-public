{"description":"BEKKs offisielle teknologiradar, publisert mai 2014.","displayDate":null,"history":"True","id":73,"ingress":"Punktene i radaren er valgt ut med bakgrunn i de utfordringene våre kunder har, erfaringene vi gjør på våre prosjekter, og arbeidet vi gjør i faggruppene våre. Radaren er et bilde av hvordan vi ser på dette landskapet nå, med henblikk på teknologiens potensiale, modenhet og tilgjengelig kompetanse – alt i en norsk kontekst.","levels":[{"id":226,"name":"Avstå","radius":0},{"id":227,"name":"Vurder","radius":0.16944681440361187},{"id":228,"name":"Bruk","radius":0.42996200946112689}],"name":"BEKKs Teknologiradar 2014","numLevels":0,"numPoints":0,"numSectors":0,"oldurl":null,"plugins":[{"id":67,"url":"Scripts\/Plugins\/default.js"}],"pointInfos":[],"points":[{"description":"I flytbaserte prosesser som Kanban, underordnes kort- og langsiktig planlegging av en kontinuerlig flyt av oppgaver. Forretningssiden kan fortløpende legge til, fjerne og reprioritere oppgaver. Det benyttes gjerne teknikker for å bryte opp eller aggregere krav til oppgaver av enhetlig størrelse, i stedet for å estimere. Nøkkelen er å finne en forretningsmessig riktig balanse mellom utførelsestid og gjennomstrømning av oppgaver, og harde grenser for mengden varer i arbeid kan være en måte å oppnå det på. En oppgave er ikke ferdig før den er i produksjon, så det bør sees i sammenheng med kontinuerlige leveranser. I BEKK foretrekker vi ofte flytbaserte metoder over tidsboksbaserte metoder som Scrum - spesielt i forvaltningsprosjekter.","id":23905,"levelFactor":0.194056967639734,"levelId":228,"name":"Kanban","number":1,"sectorFactor":0.24223788318168679,"sectorId":390,"shape":"circle","size":0},{"description":"Mange assosiserer \"smidig\" med tidsboksbaserte utviklingsmetodikker, og i Norge er det Scrum som dominerer. Prosjektet deles opp i korte leveransesykler, typisk 2 eller 3 uker, og etter hver sykel skal teamet levere en produksjonsklar løsning som oppfyller produkteiers høyest prioriterte krav. Scrum, med sine klare roller og regler, egner seg godt for organisasjoner som har begrenset erfaring med smidig utvikling, og som trenger å inkorporere smidig i en mer klassisk prosjektsetting. Vi anbefaler dog at mer modne organisasjoner bør vurdere å gå rett til flytbaserte prosesser, også for nyutvikling. ","id":23906,"levelFactor":0.68639402259030546,"levelId":227,"name":"Scrum","number":2,"sectorFactor":0.69893830562497994,"sectorId":390,"shape":"Circle","size":0},{"description":"DevOps er en samlebetegnelse for tiltak som bygger bro over det tradisjonelle gapet mellom softwareutviklere på den ene siden, og drifts- og infrastrukturspesialister på den andre. Dette har blitt relevant på grunn av behov for hyppigere og billigere utrulling av endringer, samt økt utbredelse av verktøy og plattformer som gjør dette enklere, f.eks. PaaS\/IaaS og rammeverk for automatisert utrulling og testing. I BEKK løser vi DevOps-utfordringen ved en kombinasjon av at utviklingsteamet tar ansvar for en større del av infrastruktur, konfigurasjon, utrulling og monitorering, og at driftspersonell trekkes tettere og tidligere inn i utviklingsløpet.","id":23907,"levelFactor":0.1907334771176569,"levelId":228,"name":"DevOps","number":3,"sectorFactor":0.70004624006570426,"sectorId":390,"shape":"Circle","size":0},{"description":"Hyppige leveranser reduserer risiko ved produksjonssettinger betraktelig. Når det er færre ting som går i produksjon om gangen, har man bedre oversikt over hva som har endret seg og hva som bør testes. Dette minsker behovet for omfattende regresjonstesting, og det er lettere å fikse eventuelle feil fordi man har god oversikt over hva som har endret seg. Når du leverer kontinuerlig, bør du ikke ha nedetid for hver produksjonssetting. For en web-applikasjon kan dette for eksempel løses ved å persistere sesjoner i databasen, melde en node ut av clusteret, oppgradere den, melde den inn igjen og repetere for hver node. Databasemigrering kan løses ved hjelp av \"expand\/contract\"-mønsteret (se Automatisert migrering\/rollback av database). BEKK er en pådriver for å implementere kontinuerlige leveranser i de fleste av våre prosjekter.","id":23908,"levelFactor":0.47078502479519119,"levelId":228,"name":"Kontinuerlige leveranser","number":4,"sectorFactor":0.51157362973344411,"sectorId":390,"shape":"circle","size":0},{"description":"Noen av de mest innovative kundene våre benytter en modell der team fra flere leverandører i en avgrenset periode konkurrerer om å levere en prototype på en løsning av et forretningsproblem. En slik \"proof-of-concept\" (PoC) har gjerne noen ukers varighet, men vi har avsluttet PoC-er med fullt kjørende løsning på under en uke. Kundens fordel er at ulike teknologiske plattformer og fremgangsmåter kan testes ut - og sammenlignes - i realistiske omgivelser. Dette er etter vår mening en vinn-vinn-modell der det genereres langt mer og bedre informasjon enn i en typisk anbudsprosess, og der leverandørene får et klarere bilde av kunden og dens behov enn hva anbudsdokumenter formidler. Vi hadde gjerne sett at en PoC ble grunnlaget for valg av teknologi og leverandør og skled rett over i et inkrementelt fianansiert utviklingsløp. Vi ser gode eksempler på dette i både privat og offentlig sektor. Vi vet at man også innenfor det offentlige anskaffelsesregelverket kan finne modeller som åpner for denne typen prosesser.","id":23909,"levelFactor":0.72858223915203946,"levelId":227,"name":"Smidig anskaffelse","number":5,"sectorFactor":0.43392374384473886,"sectorId":390,"shape":"Circle","size":0},{"description":"Fortsatt blir mange prosjektløp kjørt delvis etter vannfallsmetodikken. Prosjektet starter da med en detaljert spesifiseringsfase. Her bruker forretningsressurser god tid på en spesifikasjon, slik at de er sikre på hva de vil ha før det foretas en formell overlevering til et utviklingsteam. Ulempen med denne fremgangsmåten er at kommunikasjonen lider. Utviklere vil ofte ha gode innspill til forretning rundt mulighetene teknologien kan gi, og de kan prototype ideer som forretning har, slik at man tidlig kan teste ut idéene. Fremgangsmåten tar heller ikke hensyn til at krav alltid endrer seg betydelig undervis i utviklingsløpet. \u000aUtviklingsløpet etterfølges ofte av en overlevering til en forvaltningsenhet i linjeorganisasjonen. Overleveringen kan ofte være veldig formell, med mye dokumentasjon slik at forvaltning skal ha lettere for å ta over applikasjonene. Dokumentasjon gir imidlertid aldri samme kompetanse på applikasjonen som om de hadde vært med på å utvikle den. Heller enn å gjøre formelle engangs-overleveringer mellom spesifikasjon, utvikling og forvaltning, bør det være en glidende overgang mellom fasene, og ressurser fra linjeorganisasjonen bør være med i hele utviklingsløpet. Vi ser at man oppnår høy produktivitet og gode resultater i prosjekter hvor skillet mellom spesifikasjon, prosjekt og forvaltning reduseres eller fjernes.","id":23910,"levelFactor":0.78023883050564447,"levelId":226,"name":"Prosjekt-linje-organisering","number":6,"sectorFactor":0.309004616042737,"sectorId":390,"shape":"Circle","size":0},{"description":"I BEKK ser vi stadig at mindre prosjekter med ett til to små, dedikerte og tverrfaglige team resulterer i høy produktivitet og leveranser med høy kvalitet. Store prosjekter setter store krav til koordinering og kommunikasjon, som ofte gir økt risiko, kostnad og leveringstid. Det bør være en viktig prosjektledelses- og arkitekturjobb å få brutt ned mega-prosjekter til mindre (del-)prosjekter som kan leveres mer uavhengig av hverandre – også i situasjoner der lovverk, finansieringsmodell eller andre rammebetingelser krever at prosjektene organiseres i store programmer. Ikke minst gjelder dette offentlige prosjekter, der vi tror felleskapets midler kunne vært disponert smartere ved å unngå for store prosjekter.","id":23912,"levelFactor":0.72526896219961878,"levelId":226,"name":"Mega-prosjekter","number":7,"sectorFactor":0.40840614474561865,"sectorId":390,"shape":"Circle","size":0},{"description":"Funksjonelle team innebærer å ha ulike grupperinger eller avdelinger som håndterer avgrensede oppgaver knyttet til leveranser. Eksempler kan være test-\/QA-avdeling, virksomhetsarkitekt\/arkitekturråd, og driftsavdeling. Selv om det er fordeler med å holde kompetanseområder sammen, blir ofte konsekvensen at artefakter overleveres sekvensielt mellom teamene, og informasjon og kontekst går tapt i overleveringen. Utførlig dokumentasjon trengs for å bygge bro mellom grupperingene, men selv da oppstår misforståelser og informasjonshull, og tilbakemelding tar lang tid. Det er som regel mer effektivt å samlokalisere alle som bidrar til leveransene, og la koordinering mellom funksjonelle ressurser innenfor et område ha lavere prioritet og\/eller løses gjennom egne samlinger\/møter utenfor leveranseteamet.","id":23913,"levelFactor":0.16555955834400266,"levelId":227,"name":"Funksjonelle team","number":8,"sectorFactor":0.65838500798029631,"sectorId":390,"shape":"Circle","size":0},{"description":"Automatisert oppsett og utrulling gir raskere og mer smertefri utrulling, noe som spesielt er viktig under utvikling og oppsett av nye miljøer. Dette er samtidig en forutsetning for hyppige produksjonssettinger. Automatikk kan også i stor grad brukes ved oppsett av lokale utviklermaskiner\/miljø, og lokal utrulling bør bruke samme prosess som utrulling til andre miljøer. Dette sikrer at utrullingsrutinene er feilfrie og fungerer som tenkt hver gang.  Fleksibel infrastruktur i form av IaaS-\/PaaS-løsninger kan være til hjelp ved oppsett av automatiske løsninger, men er strengt tatt ingen forutsetning. Et annet aspekt er at rollback av både applikasjon og database bør fungere på samme måte. Man bør ha røyktester som kan verifisere at en løsning fungerer som den skal både etter deploy og eventuell rollback. Manuelle steg (med unntak av selve initieringen) bør unngås, da dette på et eller annet tidspunkt vil komme til å feile. Skript er den vanligste måten å implementere den automatiserte utrullingen på, men i BEKK har vi gode erfaringer med å bruke push-baserte provisjoneringsrammeverk. Ansible og Salt har vist seg bra for dette formålet.","id":23915,"levelFactor":0.74621535940377526,"levelId":227,"name":"Automatisert oppsett og utrulling","number":9,"sectorFactor":0.13920897454612788,"sectorId":390,"shape":"Circle","size":0},{"description":"Byggekjeder bør benyttes for å visualisere og kvalitetssikre alle stegene i en utrullingsprosess. Artefakter på vei fra utvikling og mot produksjonssetting, bør tvinges gjennom et sett med kvalitetssikringsledd, og prosessen bør være så automatisert som overhodet mulig. Vanlige ledd i en slik kjede kan være enhetstester, funksjonelle tester, dynamiske og statiske kodeanalyser, mutasjonstester, integrasjonstester, sikkerhetstester, ytelsestester, pakking, installering og produksjonssetting. Byggekjeden kan også inneholde manuelle steg, som for eksempel manuelle akseptansetester. De fleste CI-servere støtter nå byggekjeder.","id":23916,"levelFactor":0.72518969551095858,"levelId":227,"name":"Byggekjede","number":10,"sectorFactor":0.87699774913400708,"sectorId":390,"shape":"Circle","size":0},{"description":"Også endringer i en database skal være underlagt versjonering. For Java anbefaler vi å bruke verktøy som Flyway eller Liquibase for å få til dette. Begge verktøyene har bred støtte og er brukt hos mange av våre største kunder. Migrator.NET er et modent rammeverk for .NET-verdenen. Endringer i skjemaer bør skriptes inkrementelt, og du bør hele tiden ha mulighet for å kunne refaktorere og behandle skjemaet på samme måte som kode. Bruk versjonskontroll og sørg for å lage og teste rollback-kode. For å støtte utrulling av skjema-endringer uten nedetid, kan mønsteret \"expand\/contract\" tas i bruk. Dette innebærer først å legge ut skjema-oppdateringer som vil fungere sammen med både eksisterende og neste versjon av applikasjonen, og så å gjøre endringer\/oppdateringer som spisser skjemaet til å fungere med ny versjon først etter at den nye versjonen er produksjonssatt og stabil. Som et eksempel, kan Liquibase brukes til å verifisere at det har blitt skrevet kode for rollback og at skriptene er korrekte. Hver release kan så tagges med versjonsnummer i metadata-tabeller i databasen, og man kan da rulle frem og tilbake mellom versjoner med en enkel kommando.","id":23917,"levelFactor":0.21111896520684492,"levelId":228,"name":"Automatisk migrering\/rollback av database","number":11,"sectorFactor":0.5,"sectorId":390,"shape":"Circle","size":0},{"description":"Når du bruker et provisjoneringsrammeverk, beskriver du med kode hvordan infrastrukturen din skal se ut. Hvis du ønsker å utføre endringer, eller dersom noe feiler, kan du enkelt modifisere koden, og rammeverket vil så konfigurere infrastrukturen på nytt. Dette bidrar til at alle miljøer blir like, konfigurasjonen blir selvdokumenterende, og du kan refaktorere og forbedre infrastrukturen din inkrementelt. I tillegg blir det lett å klone opp en ny maskin eller et nytt miljø. Infrastrukturoppsettet kommer da under versjonskontroll og du kan også automatisere tester av infrastrukturen. I BEKK har vi også benyttet provisjoneringsrammeverk til utrulling av software, noe som gir økt forutsigbarhet og kvalitet ved produksjonssettinger. Det finnes mange gode provisjoneringsrammeverk, men de mest brukte i BEKK er Puppet, Ansible og Chef.","id":23918,"levelFactor":0.70474955295177955,"levelId":227,"name":"Provisjoneringsrammeverk","number":12,"sectorFactor":0.30871368535007576,"sectorId":390,"shape":"Circle","size":0},{"description":"\"Feature toggling\" sørger for at du enkelt kan skru av og på funksjonalitet i produksjon. Dette implementeres ved å omgi funksjonalitet med konfigurasjonsstyring og å gjøre den tilgjengelig ved hjelp av et flagg. Dette er nyttig dersom en feilsituasjon skulle oppstå, eller man ønsker å skille utrullingstidspunkt fra et lanseringstidspunkt. Det brukes også til delvis utrulling og testing av funksjonalitet - for eksempel for A\/B-testing eller for analyse utført av utviklingsteamet. På den måten kan man gjøre utforskning av en kjørende løsning i et produksjonsmiljø med lav risiko, og det er vanlig og uproblematisk at produksjonskodebasen inneholder uferdig kode. \"Feature toggling\" brukes også som et alternativ eller tillegg til \"feature branches\", men setter vanligvis høye krav til modenhet og disiplin i utviklingsteamet. På flere av våre prosjekter benyttes feature toggling aktivt.","id":23919,"levelFactor":0.1379423701123888,"levelId":228,"name":"Feature toggling","number":13,"sectorFactor":0.85941603888268925,"sectorId":390,"shape":"Circle","size":0},{"description":"Kodekvalitetsmetrikker måles ved at automatiske verktøy analyserer kodebasen og rapporterer verdier som antall linjer kode, testdekning, ubrukte metoder eller komplisert logikk. Selv om disse verdiene kun er indikatorer på kodebasens kvalitet, er det ifølge vår erfaring en god korrelasjon. Vi bruker slike metrikker for å flagge smertepunkter i porteføljer med gammel kode, og for å opprettholde kvalitetsfokus i ny kode. Verktøy som Sonar, PMD, Checkstyle og Findbugs har blitt brukt med gode resultater. Metrikkene er dog ingen sovepute, og problemer med arkitekturen eller funksjonelle feil fanges typisk ikke opp.","id":23921,"levelFactor":0.49879684956614068,"levelId":227,"name":"Kodekvalitetsmetrikker","number":14,"sectorFactor":0.57764988588870525,"sectorId":390,"shape":"Circle","size":0},{"description":"Ytelsestesting er stebarnet i utviklingsprosjekter. I den grad det gjøres, er det ofte en prosess som krever mye jobb å reprodusere, og det prioriteres fort ned til fordel for forretningskrav. Holdningen er gjerne at man bare kan \"kaste på mer jern\" hvis man får problemer med ytelsen. Virkeligheten er dog noe dystrere: Ytelsesproblem kan være vanskelige å lokalisere, og er ofte vanskelige å løse med mer hardware. Ytelsestester gjøres gjerne rett før lansering, eller enda verre: Etter at problemene viser seg. I stadig flere av våre prosjekter forsøker vi å bygge inn ytelesestesting som en del av den kontinuerlige utviklingsprosessen. Det er ikke alltid enkelt, men kontinuerlig testing av ytelse bør vurderes i de fleste prosjekter.","id":23922,"levelFactor":0.79781988226867162,"levelId":227,"name":"Kontinuerlig ytelsestesting","number":15,"sectorFactor":0.58936549148339235,"sectorId":390,"shape":"Circle","size":0},{"description":"For å effektivisere utviklingsarbeidet, benytter de fleste prosjekter en mengde biblioteker og komponenter lastet ned via Maven, NuGet, npm, RubyGems eller tilsvarende. Over tid vil det bli oppdaget sårbarheter i noen av disse komponentene, som det er viktig å være oppmerksom på. Etter som mengden biblioteker gjør det vanskelig å holde oversikt over versjoner og sårbarheter manuelt, er automatisering av deteksjon et viktig virkemiddel. Eksempelvis kan automatisering sørge for at bygget bryter dersom det oppdages at komponenter med kjente sårbarheter er i bruk. Eksempler på verktøy som kan hjelpe med dette er OWASP DependencyCheck, SafeNuget, Retire.js og bundler-audit.","id":23923,"levelFactor":0.3863032261147768,"levelId":227,"name":"Automatisert deteksjon av sårbare biblioteker","number":16,"sectorFactor":0.33049868107713576,"sectorId":390,"shape":"Circle","size":0},{"description":"Git er et klart førstevalg om vi kan velge kildekodesystem fritt. Den distribuerte modellen lar en utvikler jobbe effektivt på lokal maskin uten å være avhengig av nettverk eller en sentral server, og en slipper kompliserende backup-løsninger. Enkel og robust \"branch\"- og \"merge\"-funksjonalitet åpner for mer eksprimentering og uavhengig implementering av funksjonalitet - en forutsetning for \"feature branches\". Git lar deg lett bytte mellom og dele kodegrener, og lar deg enkelt hoppe til en kritisk feilretting i produksjonskoden, før du ufortrødent kan fortsette med nyutvikling. ","id":23924,"levelFactor":0.43444070803942336,"levelId":228,"name":"Distribuert VCS","number":17,"sectorFactor":0.20823711605769687,"sectorId":390,"shape":"Circle","size":0},{"description":"Sentraliserte kildekodesystemer, som Subversion og TFS, er fortsatt vanlige og vil være utbredt en stund framover. De er velprøvde og stabile, og funksjonelt rike. Imidlertid kommer de ofte til kort dersom man bruker kodegrener og kodesammenfletting i et visst omfang – noe som vil være naturlig om man ønsker å gjøre kontinuerlige leveranser. Vi anbefaler heller distribuerte kildekodesystemer (for eksempel Git) som derimot er sterke på dette området. Distribuerte kildekodesystem gir også større fleksibilitet hos den enkelte utvikler ved å støtte lokale kodegrener og flere lokale innsjekk før dette sendes til den sentrale databasen og blir synlig for andre.","id":23925,"levelFactor":0.749017361184773,"levelId":226,"name":"Sentralisert VCS","number":18,"sectorFactor":0.56500973703032531,"sectorId":390,"shape":"Circle","size":0},{"description":"Tidligere ble web-grensesnitt genererert på server-siden, med små JavaScript-snutter som beriket opplevelsen. Nå foretrekker vi rene JavaScript-klienter som snakker med tilstandsløse REST-tjenester. Web-serveren leverer en enkel oppstartsside med linker til JavaScript-applikasjonen, og deretter tar JavaScript-motoren i nettleseren over og genererer brukeropplevelsen med data fra tjenestene. REST-tjenestene kan brukes av andre klienter, som \"native\" mobil-klienter. Gjort riktig, blir brukeropplevelsen vesentlig bedre enn med server-generert HTML. Vår erfaring er at utviklingshastigheten går opp, men det krever at man har ressurser med god frontend-kompetanse. Selv om det er ønskelig med polyglot-utviklere som behersker både frontend og backend, ser vi i praksis en polarisering i kompetansen. Se punktet \"Rendre gui på server\" for motargumenter mot JavaScript-klienter.","id":23926,"levelFactor":0.70058120902655463,"levelId":228,"name":"JavaScript-klienter","number":19,"sectorFactor":0.69667141987407988,"sectorId":393,"shape":"Circle","size":0},{"description":"I en hendelsesdrevet (\"event driven\") arkitektur, agerer systemet asynkront idet en gitt hendelse inntreffer i stedet for gjennom eksplisitte operasjoner eller metodekall. Dette brukes i utstrakt grad i javascript, for eksempel ved å reagere på hendelser i brukergrensesnittet. Men hendelsesdrevet arkitektur kan også benyttes i andre deler av systemet, slik at asynkrone hendelser medfører operasjoner eller endringer i datamodellen. Den asynkrone naturen gir et godt grunnlag for skalering, parallellisering og toleranse for feil eller nedetid. Ulemper som bør nevnes, er at at man kan få en litt mer uoversiktlig arkitektur der det kan være vanskelig å følge flyten, og at det kan være vanskeligere å ha kontroll på rekkefølgen av operasjoner.","id":23929,"levelFactor":0.13104818241782051,"levelId":228,"name":"Hendelsesdrevet arkitektur","number":20,"sectorFactor":0.224720660346312,"sectorId":391,"shape":"Circle","size":0},{"description":"Lagdeling i arkitekturen lever fremdeles i beste velgående som en mekanisme for å fordele ansvar, strukturere applikasjonen og isolere mot endringer. Men mens vi tidligere ofte benyttet en tradisjonell 3-lags-arkitektur, ser vi nå oftere andre former for lagdeling. Presentasjonslaget deles for eksempel oftere i et tjenestelag som leverer et web-api til en js-klient som står for selve presentasjonen og visningslogikken. Det tidligere persistenslaget integrerer nå i større grad mot ulike datalagringsplattformer (\"polyglot persistence\"), i tillegg til andre typer tjenester som tilbyr lesing og skriving av data. Det tidligere forretningslaget har også endret karakter og realiseres i større grad av samarbeidende tjenester, gjerne mikro-tjenester, som kan være utviklet med flere enn ett språk (\"polyglot programming\").","id":23930,"levelFactor":0.16225291558583491,"levelId":228,"name":"Lagdelt arkitektur","number":21,"sectorFactor":0.79286897895889641,"sectorId":391,"shape":"Circle","size":0},{"description":"For å lage tjenester som kan rulles ut automatisk og ofte, vil det være lønnsomt å få ned kompleksiteten. Mikrotjenester kan være med på å løse dette. Det innebærer små, uavhengige tjenester med svært lite kode, som løser et begrenset problem. Tjenester kan ha et grensesnitt, eller leve helt for seg selv. Flere mikrotjenester kan settes sammen for å danne løsninger via aggregerings-mekanismer. Det arketypiske eksempelet er kommandolinjeverktøyene i linux\/unix, som grep, sed og awk, men tankesettet kan brukes i mange sammenhenger. En viktig - men ikke triviell - forutsetning er at du har kontroll på versjons- og utrullingsregimet ditt, slik at tjenestene spiller sammen til enhver tid.","id":23931,"levelFactor":0.11093477352360157,"levelId":228,"name":"Mikrotjenester","number":22,"sectorFactor":0.93226820506004637,"sectorId":391,"shape":"Circle","size":0},{"description":"En del rammeverk krever tett kobling til koden, hvor Hollywood-prinsippet \"Don't call us, we'll call you\" gjelder. Hvis denne typen rammeverk ikke kan unngås, anbefaler vi at et anti-korrupsjonslag innføres for å holde forretningslogikken ren. Guice er et DI-rammeverk på fremmarsj, som er enklere å bruke og mindre invaderende enn Spring.","id":23932,"levelFactor":0.43164646945846319,"levelId":228,"name":"Ikke-invaderende rammeverk","number":23,"sectorFactor":0.16528535557376434,"sectorId":392,"shape":"Circle","size":0},{"description":"Ved bruk av asynkrone tjenester sender man inn en forespørsel for å få svar på et senere tidspunkt. I en verden hvor en web-side vil medføre flere og flere web-kall, er asynkronitet viktig for å holde ytelsen oppe. Ved å bruke slike kall, kan applikasjonen utføre større og flere oppgaver samtidig som brukeren opplever god responstid og mer samtidighet i arbeidsflyten. Ved hjelp av asynkrone tjenester kan man kan også lettere bygge inn robusthet i systemer og utnytte maskinressurser bedre. Vi understreker likevel at bruk av asynkrone tjenester må planlegges og vurderes nøye ut fra både et arkitekturmessig og funksjonelt ståsted for å sikre konsistens i systemer og en riktig brukeropplevelse. BEKK har stor bruk av asynkrone tjenester i de fleste prosjekter.","id":23933,"levelFactor":0.1549714584242772,"levelId":228,"name":"Asynkrone tjenester","number":24,"sectorFactor":0.41092118807049638,"sectorId":391,"shape":"Circle","size":0},{"description":"Actors er en gammel programmeringsmodell som har fått en ny vår de siste årene, gjennom rammeverk som Akka. Actor-modellen løser problemer rundt skalering over flere cpu-er og maskiner. Problemer rundt låsing og synkronisering fjernes ved å bryte oppgaver ned til enheter med arbeid som kjøres isolert. Akka kan brukes fra både Scala og Java, og har fokus på ytelse og feiltoleranse. Vi har med hell tatt i bruk Akka på noen prosjekter, og kommer til å vurdere det på nye prosjekter med behov for stor grad av asynkronitet.","id":23934,"levelFactor":0.811617409418224,"levelId":227,"name":"Actors","number":25,"sectorFactor":0.36079102545387215,"sectorId":391,"shape":"Circle","size":0},{"description":"Protokollen fungerer forsåvidt, men er tung og understøtter ikke løst bundet og skalerbar arkitektur på samme måte som godt designede REST-tjenester. Problemene med kryss-plattform-integrasjon er fortsatt ikke løst, på tross av at standarden har vært i bruk i over 10 år. WS-* blir for omfattende for praktisk bruk eller medfører tunge utrullingsregimer og krevende feilsøking. Både med tanke på enkelhet i bruk og arkitekturmønstre\/-prinsipper, så mener vi at standarden er på vei til å bli utdatert. Hvis man har muligheten, bør bedre og lettere alternativer velges.","id":23935,"levelFactor":0.51229548231081823,"levelId":226,"name":"SOAP\/WS-*","number":26,"sectorFactor":0.53796209101968173,"sectorId":391,"shape":"Circle","size":0},{"description":"REST er like mye applikasjonsdesign som selve protokollen. Brukt riktig kan REST-tankegang bidra til gode tjenester, desentralisert infrastruktur, effektiv ressursbruk, lav kompleksitet og god skalering. Det passer som hånd i hanske med arkitektur som er basert på mindre, løst koblede komponenter (typisk sky-arkitektur\/mikrotjenester), og samtidig for løsninger som har ulike konsumenter\/frontend-løsninger. REST på nivå 1 innebærer å bruke URL-adresserbare ressurser over HTTP, og nivå 2 HTTP-verb for å gjøre operasjoner på ressursene. Denne formen for REST er den vi ser desidert mest av på prosjekter, selv om puristene vil si at det ikke er REST i det hele tatt. REST er enklere både å utvikle og teste fremfor alternativer som WS\/SOAP, samtidig som det er mindre behov for biblioteker og rammeverk som f.eks. CXF.","id":23936,"levelFactor":0.41480818108699513,"levelId":228,"name":"REST nivå 1-2","number":27,"sectorFactor":0.12566591637800231,"sectorId":391,"shape":"Circle","size":0},{"description":"Sann REST, som betyr hypermediakontroll. I tillegg til adresserbare ressurser og bruk av HTTP-verb, så returnerer tjenestene svar som også indikerer hvordan klienten kan komme videre. Typisk legges det linker til ressurser, med relasjoner som forteller hvordan ressursene kan manipuleres. Fordelen er at klienten ikke trenger å snekre sammen nye URL-er basert på en implisitt protokoll, samtidig som serversiden står fritt til å endre adresseringen av ressurser. I BEKK gjør vi prosjekter også på dette nivået, men fortsatt er det nybrottsarbeid.","id":23937,"levelFactor":0.030270321757625972,"levelId":227,"name":"REST nivå 3","number":28,"sectorFactor":0.8144528418445155,"sectorId":391,"shape":"Circle","size":0},{"description":"En lettvekts applikasjonsserver forenkler infrastruktur og konfigurasjon betraktelig og gjør det lettere å skreddersy applikasjonen med de utvidelser, rammeverk og biblioteker som er nødvendige. Drift og forvaltning blir kraftig forenklet, særlig om man embedder appcontaineren. Applikasjonen kjører som én prosess som er enkel å starte, stoppe og monitorere. Det blir også mye enklere å gjennomføre testing, implementere nedetidsfri produksjonssetting og konfigurasjon i kode. Serverne er som regel lite ressurskrevende og kan kjøre på utviklernes eller forretning sine maskiner. I BEKK har vi god erfaring med Jetty fra flere prosjekter.","id":23938,"levelFactor":0.41817836222474419,"levelId":228,"name":"Lettvekts applikasjonsservere","number":29,"sectorFactor":0.71887357082867,"sectorId":391,"shape":"Circle","size":0},{"description":"Java EE-standardene spesifiserer hvilke tjenester og krav Java EE applikasjonsservere må oppfylle. Dessverre er det flere uklarheter og hull i disse spesifikasjonene som gjør at forskjellen mellom de ulike implementasjonene kan være stor. Samtidig har flere av implementasjonene (spesielt de kommersielle) utviklet egne tjenester som utvidelser eller tillegg til spesifikasjonen. Dette vanskeliggjør senere migrering og oppgradering av applikasjonsservere, og binder i større grad applikasjonene til en spesiell applikasjonsserver. I tillegg tilbyr applikasjonsserverene ofte så mange tjenester at det kan være vanskelig å utvikle, tilpasse og drifte løsningene på denne plattformen. Mangel på enkelhet og oversikt gjør kontinuerlige leveranser tyngre. Resultatet kan være utilsiktede driftsbrudd og feil i applikasjonene. Et annet aspekt er at utviklere ofte velger rammeverk (f.eks. Spring) som i liten grad har behov for de innebygde tjenestene. Vi setter derfor spørsmålstegn ved verdien av de store Java EE applikasjonsserverene, og mener man bør vurdere å velge lettvektsvariantene i nye prosjekter.","id":23939,"levelFactor":0.811116510511297,"levelId":226,"name":"Java EE 5\/6 applikasjonsservere","number":30,"sectorFactor":0.39747369784122966,"sectorId":391,"shape":"Circle","size":0},{"description":"En ESB sørger for transformasjon og ruting av meldinger mellom tjenester i en tjenesteorientert arkitektur (SOA). Kommersielle produkter tilbyr gjerne et bredt spekter av funksjonalitet, som monitorering, sikkerhet, last-balansering, versjonering, kø- og feilhåndtering. Imidlertid ser vi ofte at ESB-produktene blir unødvendig komplekse og i liten grad gir den verdiøkningen som er forespeilet. Ofte er også teamet som forvalter bussen for lite, og blir en flaskehals i utviklingsarbeidet. I den grad en \"tjenestebuss\" i det hele tatt trengs, bør lettvektsalternativene vurderes først.","id":23940,"levelFactor":0.73317148349779071,"levelId":226,"name":"Enterprise Service Bus","number":31,"sectorFactor":0.13989314383927939,"sectorId":391,"shape":"Circle","size":0},{"description":"Automatisering av miljø og utrulling kan spare voldsomt med tid og frustrasjon, og er en forutsetning for hyppigere produksjonssettinger. En fleksibel infrastuktur (i form av IaaS eller PaaS-løsninger) kan være hjelpsomt, men strengt tatt ikke nødvendig. En privat PaaS-løsning vil kunne gi store fordeler ved utrulling og oppsett av applikasjoner, både ved produksjonssetting og under utvikling. Det er lav terskel for eksperimentering med oppsettet, og det kan forenkle utviklingsløp og kontinuerlig utrulling betraktelig.","id":23943,"levelFactor":0.5096161738851458,"levelId":227,"name":"Private PaaS\/IaaS ","number":32,"sectorFactor":0.26813755105089804,"sectorId":391,"shape":"Circle","size":0},{"description":"\"Public PaaS og IaaS er det tryggeste valget dersom man ønsker å bruke clouds i dag. Leverandørene, som Microsoft Azure, Heroku og Amazon AWS, er veldig modne og har vist gjennom mange år at de stort sett leverer sikre og tilgjengelige løsninger. Vi har brukt disse leverandørene med suksess på flere av våre prosjekter. \u000aDen største fordelen med public fremfor private er at man slipper en større investering i infrastruktur og kan være veldig fleksibel rundt opp- og nedskalering, og automatisering av installasjon og konfigurasjon. Det tilbys også mange tjenester som gir god verdi. En utfordring kan være usikkerheten rundt å plassere sine data utenfor sitt eget datasenter. Så lenge man holder seg innenfor lovverket og evaluerer leverandøren godt, ser vi få problemer med det. Datatilsynet har godkjent å bruke Google Apps i kommunene, og Microsoft Azure er blitt godkjent for bruk i det offentlige i Sverige. BEKK har flere prosjekter kjørende på Public PaaS.\"","id":23944,"levelFactor":0.66174343666495317,"levelId":227,"name":"Public PaaS\/IaaS ","number":33,"sectorFactor":0.90966552939826684,"sectorId":391,"shape":"Circle","size":0},{"description":"Web-baserte mobil- og småflateapper er tilsynelatende det enkle valget når man skal lage innhold for små flater. HTML5 og CSS3 har god støtte hos de markedsledende mobil- og nettbrettleverandørene, men det er selvfølgelig nok varianter til at avansert bruk skaper hodebry. I tillegg mister brukeren den kjente brukeropplevelsen fra enheten, og ytelsen og funksjonsrikheten når aldri opp til \"native\" app-er. \"Responsive Design\" er et nøkkelord for å lage web-innhold som fungerer på mange flater.","id":23945,"levelFactor":0.099450272527284084,"levelId":228,"name":"Web-basert mobilapp","number":34,"sectorFactor":0.87790387670562253,"sectorId":393,"shape":"Circle","size":0},{"description":"Med native apps får du som regel bedre ytelse og et mer responsivt brukergrensesnitt. Du kan ta i bruk sensorer, ulike nettverk, krevende grafikk og lyd. Brukere forventer god kvalitet og apper som ser ut som de hører til på plattformen. I dag er plattformene iOS, Android og Windows Phone de mest relevante. Hvis du vil støtte alle disse, må du skrive store deler av kodebasen tre ganger. Smart gjenbruk kan derimot gjøres for eksempel på en server backend. Hvis appen din holder høy kvalitet, kan den få ekstra eksponering i app-butikkene. Mange leter også først i butikkene når de trenger en app. Hvis appen skal løse relativt enkle informasjonsbehov som brukere lettere kan finne ved hjelp av en søkemotor, bør du vurdere en nettside i stedet.","id":23947,"levelFactor":0.97627261244732355,"levelId":227,"name":"Native-app","number":35,"sectorFactor":0.46572430743891557,"sectorId":393,"shape":"Circle","size":0},{"description":"I disse NoSQL-tider er det fristende å tenke at RDBMS-løsninger havner på historiens skraphaug. Det er feil, og relasjonsdatabaser vil være en hjørnesten i de fleste forretningsløsninger i årene fremover. I BEKK har vi god erfaring med et bredt spekter av relasjonsdatabaser, og vi ser at åpne systemer som MySQL og PostgreSQL holder godt følge med de kommersielle tungvekterne som Microsoft og Oracle. Som alltid er det lurt å unngå de mest proprietære SQL-tilpasningene, og holde forretningslogikken utenfor databasen slik at man ikke går på kompromiss med testbarhet.","id":23948,"levelFactor":0.62323011343098778,"levelId":228,"name":"Relasjonsdatabaser","number":36,"sectorFactor":0.73375012250468685,"sectorId":391,"shape":"Circle","size":0},{"description":"Hovedgevinsten ved å bruke en Key-value database er at de har rask lagring og\/eller uthenting av data. De støtter gjerne store volumer og enkel opp- og nedskalering etter behov. En annen fordel er at det gjerne stilles få krav til skjema\/struktur, som gir mye fleksibilitet og bevegelsesfrihet. Redis er en meget rask minnebasert key-value-database med store mengder funksjonalitet, og passer godt til å \"lime\" sammen diverse aspekter ved webapplikasjoner. Et annet godt alternativ er RIAK som tilbyr sharding, speiling og fleksibel konsistens og er godt egnet store mengder til kritiske data. BEKK har god erfaring med å bruke key-value databaser som en del av databasearkitekturen.","id":23949,"levelFactor":0.81866121151872506,"levelId":227,"name":"Key-value-databaser","number":37,"sectorFactor":0.73773205507873052,"sectorId":391,"shape":"Circle","size":0},{"description":"Elasticsearch er en Java-basert server som kan brukes som søkemotor, dokumentdatabase, \"key-value\"-database eller for å dekke litt enklere \"Business Intelligence\"-behov. Den har avansert funksjonalitet for clustering, sharding, redundant lagring og kan dekke de fleste sanntids- og skaleringskrav. Samtidig er produktet lett å sette opp i basiskonfigurasjon og har et avansert REST-basert API. Elasticsearch er nylig sluppet i versjon 1.0 og har litt mindre fartstid enn Lucene-slektningen Solr. BEKK bruker etterhvert Elasticsearch på mange prosjekter, både som klassisk søkemotor og som datalager.","id":23950,"levelFactor":0.31336845736930086,"levelId":228,"name":"Elasticsearch","number":38,"sectorFactor":0.59033447060173316,"sectorId":392,"shape":"Circle","size":0},{"description":"Grafdatabaser er i vinden om dagen, og får velfortjent mye oppmerksomhet i markedet. Grafdatabaser lagrer dataene i strukturerte grafer i stedet for tabeller, og passer særdeles godt til assosiative datamengder. Neo4J er den mest populære grafdatabasen på markedet i dag og er kommersielt backet av Neo Technologies. Neo4J håndterer milliarder av datanoder og relasjoner, og slår selvfølgelig RDBMS-systemer ned i støvlene i nettverksspørringer. Det siste året har vi brukt Neo4J i flere prototyper, og flere kunder vurderer å ta det i bruk i produksjon i løpet av de neste årene. Vi tror grafdatabaser har en lys framtid foran seg.","id":23951,"levelFactor":0.068648116275189228,"levelId":228,"name":"Grafdatabaser","number":39,"sectorFactor":0.0742209562580284,"sectorId":391,"shape":"Circle","size":0},{"description":"Hvis du i liten grad jobber med relasjonelle data i domenet ditt, kan det være nyttig å vurdere en dokumentdatabase. Dokumentdatabasene har lite fokus på koblinger mellom data, og er optimalisert for horisontal skalering. MongoDB er en moden dokumentdatabase med kommersiell backing, avansert funksjonalitet for dataaggregering og den oppfyller konsistens og partisjonstoleranse fra CAP-teoremet. CouchDB er en velprøvd dokumentdatabase som yter noe høyere på leseoperasjoner på grunn av en avansert versjoneringsstrategi. CouchDB oppfyller dermed tilgjengelighet og partisjonstoleranse. Vi benytter dokumentdatabaser i flere av våre prosjekter.","id":23952,"levelFactor":0.11896684251090985,"levelId":228,"name":"Dokumentdatabaser","number":40,"sectorFactor":0.61018362356563616,"sectorId":391,"shape":"Circle","size":0},{"description":"De siste årene har utfordringer med ORM blitt tydeligere. Hovedutfordringen er at modellen i databasen ikke treffer modellen i applikasjonen, og kanskje passer heller ikke en relasjonell modell i det hele tatt. Dette har ført til en fremvekst av alternative persistensmodeller som dokumentdatabaser og grafdatabaser. Disse databasetypene fungerer i en del tilfeller bedre enn relasjonsdatabaser for domenemodeller som det skal programmeres mot.\u000aI tilfeller hvor man bruker en relasjonsdatabase, er det vår erfaring at ORM-rammeverk kan være komplekse og vanskelige å bruke riktig, og ikke alltid gir den gevinsten som de lover. Ofte er det enklere, mer hensiktsmessig og lavere risiko for feil ved å manipulere SQL direkte enn å introdusere et abstraksjonslag imellom.","id":23953,"levelFactor":0.20675412130482235,"levelId":227,"name":"ORM-rammeverk","number":41,"sectorFactor":0.34404173924526132,"sectorId":392,"shape":"Circle","size":0},{"description":"Implementasjon av mekanismer som håndterer passord, kryptering eller beskytter mot \"Cross Site Scripting\", er ofte mye vanskeligere enn man tror. På StackOverflow finnes det store mengder godtatte svar som er direkte feil. Innen sikkerhet bør man derfor velge rammeverk som er godt testet og bruker mekanismene på riktig måte. Spring Security er et modent Java-rammeverk for autentisering og autorisering.  For enklere eller mindre løsninger, kan Apache Shiro være et godt alternativ. Apache Shiro er et Java-rammeverk som håndterer autentisering, autorisering, sesjonshåndtering og kryptering. Det har god støtte for tilleggsfunksjonalitet en vanligvis ikke finner i slike rammeverk, som korrekt caching av bruker-objekter og \"husk meg\"-støtte ved innlogging. OWASP AntiSamy gjør det mulig å la brukere publisere HTML uten at det utsetter applikasjonen for XSS-sårbarheter. Det er viktig at Antisamy-policyen er restriktiv. Jo åpnere policyen er, jo større risiko har en for å introdusere hull som gjør at en ondsinnet bruker kan injisere kjørbar kode. BEKK benytter denne type rammeverk i de fleste av våre prosjekter.","id":23954,"levelFactor":0.18169405774806355,"levelId":228,"name":"Sikkerhetsrammeverk","number":42,"sectorFactor":0.14138172983802638,"sectorId":392,"shape":"Circle","size":0},{"description":"Store datamengder og mer distribuerte og autoskalerbare systemer legger til rette for bruk av grid-løsninger både for dataprosessering og caching på tvers av mange instanser. I BEKK har vi prosjekterfaring med GemFire og Hazelcast. Sistenevnte er åpen kildekode og fungerer fint både for enkel synkronisering mellom maskiner og større datasentrerte systemer.","id":23955,"levelFactor":0.20930818890357417,"levelId":227,"name":"Grid-rammeverk","number":43,"sectorFactor":0.58059105125250421,"sectorId":392,"shape":"Circle","size":0},{"description":"Mens Java 7 kom med litt syntaktisk sukker, gir Java 8 oss endelig støtte for funksjonell programmering. Dette er sårt etterlenget, snart 10 år etter at C# gav det samme til .NET-verdenen. Det blir spennende å se om det er tilstrekkelig til å dytte Scala ned fra den funksjonelle tronen i JVM-sfæren. I tillegg kommer Java 8 med forbedringer i sikkerhet og parallellisering, samt en del annen nyttig funksjonalitet. Vi anbefaler alle å bruke Java 8 på nye prosjekter – og anbefaler de som kan, å oppgradere til dette på eksisterende prosjekter.","id":23956,"levelFactor":0.71977145903199857,"levelId":228,"name":"Java 8","number":44,"sectorFactor":0.44478065857655225,"sectorId":392,"shape":"Circle","size":0},{"description":"Scala er en hybrid av funksjonelt og objektorientert språk som kjører på JVM-en. Med et avansert typesystem og kompilering direkte til JVM-\"bytecode\", tilbyr Scala både konsis syntaks, vanligvis forbundet med dynamiske språk, og kjøretidsytelse på høyde med Java eller bedre. Scala har i de siste årene blitt et av de aller mest populære alternative språkene på JVM-en og brukes i store forretningskritiske systemer hos bl.a. LinkedIn, Twitter og The Guardian. Scala har lav terskel for Java-utviklere og avansert IDE-støtte i både Eclipse og IntelliJ. I BEKK bruker vi Scala i flere kundeprosjekter i kombinasjon med og Lift, Play Framework, Scalatra og Akka. Scala kan tas inn i eksisterende utviklingsmiljø, rulles ut på eksisterende Java-infrastruktur og er et reelt alternativ til Java. Selv med Java 8 tilgjengelig vil Scala være attraktivt. Med bedre støtte for funksjonell programmering og mer avansert typesjekking vil man kunne skrive mer konsis kode som er enklere å vedlikeholde.","id":23957,"levelFactor":0.32390977610045452,"levelId":228,"name":"Scala","number":45,"sectorFactor":0.36760947698594415,"sectorId":392,"shape":"Circle","size":0},{"description":"Clojure er en dynamisk typet, funksjonell, LISP-dialekt som kompilerer direkte til JVM-bytekode. Med økende krav til parallellisering og derigjennom et ønske om å skrive funksjonell kode, har Clojure blitt et utbredt og akseptert alternativ på JVM-en. Clojure har veldig god interoperabilitet med Java, og gjør det mulig å skrive konsis funksjonell kode både for backend og frontend. En rekke store selskaper og produkter bruker Clojure i dag, blant annet Prismatc, Datomic, Trend Micro, Puppet Labs, Citigroup, Netflix og Walmart mobile. Clojure er et språk vi har tro på og som vil kunne være aktuelt for de rette prosjektene. Det er dog viktig for disse prosjektene å vurdere tilgangen på Clojure-kompetansen i det norske markedet før man starter opp.","id":23958,"levelFactor":0.50150341310797264,"levelId":227,"name":"Clojure","number":46,"sectorFactor":0.89144777721631985,"sectorId":392,"shape":"Circle","size":0},{"description":"Funksjonell programmering er et viktig paradigme, og stadig mer i bruk på prosjektene vi jobber på. F# er statisk typet, funksjonelt-først, open source programmeringsspråk fra Microsoft for CLR-en. F# er nå i versjon 3.1, og opplever økende adopsjon rundt om i industrien. F# er et fullt støttet språk fra Microsoft, med god verktøystøtte i Visual Studio, og samme supportavtaler som for C# og .NET. Microsoft har fra første versjon av språket lagt opp til sømløs integrasjon mellom C# og F#, noe som gjør det mulig å skrive deler av løsningen i F#, og andre deler av løsningen i C#. Mange av nyhetene i C# er hentet fra F#, async\/await i C# 5.0 er basert på Asynchronous Workflows fra F# 2.0. F# egner seg også godt som skriptspråk, og F# Interactive kan brukes til utforskende programmering og prototyping. I BEKK har vi prøvd ut F# på deler av noen mindre systemer, og vil fortsette å bygge kompetanse på dette språket.   ","id":23960,"levelFactor":0.57220162109996375,"levelId":227,"name":"F#","number":47,"sectorFactor":0.69625927937984444,"sectorId":392,"shape":"Circle","size":0},{"description":"Skal du lage en ny web-løsning på .NET i dag, er MVC 5 det selvfølgelige valget. MVC gjør det lett å skille mellom visning og logikk, og er generelt mer testbart en sin storebror WebForms. Razor er også en god visningsmotor som gir deg som utvikler full kontroll på HTML-en som blir generert. Det kommer godt med i disse HTML5-tider.\u000aWeb API er et rammeverk fra Microsoft som gjør det enkelt å lage HTTP-tjenester, f.eks. REST. Både MVC og Web API er gitt ut under en open source-lisens.","id":23963,"levelFactor":0.33019276886411775,"levelId":228,"name":"ASP.NET MVC","number":48,"sectorFactor":0.89037992285461842,"sectorId":392,"shape":"Circle","size":0},{"description":"Apache Wicket er et komponentorientert web-rammeverk i Java. Det har vært populært de siste 4-5 årene som et alternativ til JSF, og vi har gjort vår andel av web-prosjekter med Wicket. Nå er den komponentorienterte web-æraen på hell, og vi ville ikke startet et nytt web-prosjekt på Wicket i dag. Wicket har en høy terskel for riktig bruk og det er lett å ende opp med tette bindinger mellom frontend-kode og forretningslogikk.","id":23970,"levelFactor":0.035840155718555589,"levelId":227,"name":"Wicket","number":49,"sectorFactor":0.16831026367574806,"sectorId":392,"shape":"Circle","size":0},{"description":"Spring var tidlig ute med å tilby et MVC-rammeverk for Java. Som de fleste spring-rammeverkene oppleves det litt \"oppblåst\", og det blir gjerne en del standardkode for å knytte sakene sammen. Det er likevel et rammeverk som er svært stabilt og får jobben gjort, og vi har brukt det i flere prosjekter. Dokumentasjonen holder høy kvalitet, og det er ikke vanskelig å finne utviklere med kompetanse på plattformen. Spring MVC er et greit valg om man ønsker et server-rammeverk for klient-kode. På de fleste nye prosjekter, benytter vi heller en REST-basert backend med Jersey kombinert med en ren JavaScript\/HTML-basert frontend – og da er Spring MVC mer i veien enn til nytte.","id":23971,"levelFactor":0.54208936502677518,"levelId":227,"name":"Spring MVC","number":50,"sectorFactor":0.54197997452401769,"sectorId":392,"shape":"Circle","size":0},{"description":"Når vi får større og mer komplekse klientside-applikasjoner, blir det større krav til minifisering og testing. Vi mener Node.js er det beste verktøyet for å løse dette problemet. Dette inkluderer blant annet byggesystem som Grunt og Gulp, pakkehåndtering med Bower, kjøring av tester på tvers av nettlesere med Karma og en rekke andre oppgaver som ikke er godt støttet på andre plattformer. Vi har erfaring med å bruke Node.js som støtteverktøy i mange prosjekter.","id":23973,"levelFactor":0.15302878959639929,"levelId":228,"name":"Node.js som støtteverktøy","number":51,"sectorFactor":0.782926056243018,"sectorId":392,"shape":"circle","size":0},{"description":"Vi har fortsatt kunder som ønsker å bruke JSF siden det er en del av JEE-standarden. Vår erfaring med JSF er at rammeverket i en del tilfeller forlenger utviklingstiden og gjør spesialtilpasninger vanskelig. Det kreves en del av utviklere for å bruke JSF på riktig måte – og selv da kan det oppleves som mer til hinder enn til hjelp. JSF 2.2 hevder å ha løst mange av de tidligere problemene med rammeverket, men vi mener det kommer for sent. Vårt førstevalg vil ofte være en ren REST-backend med JavaScript\/HTML-basert frontend for web-applikasjoner med rikt brukergrensesnitt. ","id":23975,"levelFactor":0.35865016292190843,"levelId":226,"name":"JavaServer Faces ","number":52,"sectorFactor":0.71064648227895766,"sectorId":392,"shape":"Circle","size":0},{"description":"Med WebSockets kan vi opprette toveis tilkobling mellom nettleser og server, slik at vi blant annet kan pushe data fra serveren til nettleseren når som helst. Vi har sett at WebSockets kan muliggjøre en rekke nye features, og eneste grunnen til at vi enda ikke er klar for å flytte WebSockets til Bruk er at det ikke støttes før IE10. Det betyr at vi fortsatt må falle tilbake på andre kommunikasjonsmetoder, som for eksempel long-polling. Det finnes en rekke biblioteker for å håndtere dette automatisk både for frontend og for backend, også i .NET og Java. Vi har stor tro på WebSockets og bruker det allerede på flere prosjekter.","id":23978,"levelFactor":0.83188548794703931,"levelId":227,"name":"WebSockets","number":53,"sectorFactor":0.1091969334573677,"sectorId":393,"shape":"Circle","size":0},{"description":"Sass er en preprosessor til CSS som gir variabler, \"mixins\" og  funksjoner. Det kompilerer ned til ren CSS med en JavaScript-kompilator. Preprosessereren er skrevet i Ruby, som kan være marginalt vanskeligere å innføre enn lillebroren LESS, som er skrevet i JavaScript. Sass er generelt ansett for å være litt kraftigere enn LESS — noe som kan være \"a blessing and a curse\" siden det er litt for lett å lage for komplekse ting. Vi anbefaler å bruke Sass\/LESS i prosjekter som starter opp nå.","id":23979,"levelFactor":0.49883516275452522,"levelId":228,"name":"SASS, LESS","number":54,"sectorFactor":0.465621577123143,"sectorId":393,"shape":"triangle","size":0},{"description":"Webapplikasjoner blir stadig større og mer komplekse på klientsiden. Dette medfører at behovene for å modularisere og strukturere JavaScript-kode øker. RequireJS er en implementasjon av AMD-standarden for definering av moduler og hvordan avhengigheter mellom moduler skal spesifiseres og løses. Vi bruker det veldig ofte i nye single-page apps. Dersom man ønsker å benytte CommonJS-standarden istedenfor AMD, kan Browserify vurderes.","id":23981,"levelFactor":0.7091284854182851,"levelId":228,"name":"RequireJS","number":55,"sectorFactor":0.30452861597575992,"sectorId":393,"shape":"Circle","size":0},{"description":"jQuery er fortsatt et fantastisk bibliotek for å jobbe med DOM-en og for å gjøre Ajax-kall. Problemet er at det er lett å bli DOM-sentrisk og bruke mange anti-patterns. For eksempel er det lett å koble applikasjonen for mye til DOM-en. I IE9+ er nettleser-støtten såpass god at man ikke alltid trenger jQuery lengre. Alt i alt fortsatt et veldig godt bibliotek som er essensielt på de fleste prosjekter, men det er viktig å vurdere både behovet og bruken av biblioteket.","id":23984,"levelFactor":0.52181017566790588,"levelId":228,"name":"jQuery","number":56,"sectorFactor":0.81933105879653367,"sectorId":393,"shape":"Circle","size":0},{"description":"Funksjonelle hjelpemetoder, som blant annet foreach, map, reduce og filter, mener vi nærmest er å betrakte som et \"must\" i moderne JavaScript-utvikling. Lenge har Underscore.js vært en essensiell del av denne verktøykassen, men biblioteket har fått sterk konkurranse fra både Lo-Dash og JavaScript selv. For eksempel er det i alle nyere nettlesere (IE9+) blant annet god støtte for mange av disse hjelpemetodene ut av boksen, slik at vi ikke trenger tredjeparts biblioteker for de mest sentrale funksjonene. Dersom du har behov for flere hjelpefunksjoner eller støtte for eldre nettlesere, anbefaler vi både Underscore.js og Lo-Dash.","id":23985,"levelFactor":0.13893316802749564,"levelId":228,"name":"Funksjonell JavaScript","number":57,"sectorFactor":0.52614774295675892,"sectorId":392,"shape":"Circle","size":0},{"description":"Selv om Angular.js har fått veldig mye av interessen det siste året, har vi fortsatt stor tro på Backbone. Der Angular.js gir deg veldig mye ut av boksen, gir Backbone små, fokuserte komponenter. Backbone er fortsatt såpass lite at man enkelt kan lese gjennom kodebasen på en ettermiddag. Det er også veldig enkelt å teste når man følger god praksis, som blant annet \"\"dependency injection\"\". Samtidig krever Backbone ofte mer JavaScript-kompetanse på forhånd. Vi har hatt stor suksess med Backbone i mange BEKK-prosjekter, og vi tror både Angular og Backbone er gode valg også i tiden fremover.","id":23986,"levelFactor":0.37344358251065529,"levelId":228,"name":"Backbone","number":58,"sectorFactor":0.65262520339580632,"sectorId":393,"shape":"Circle","size":0},{"description":"Angular.js har vært den store hypen det siste året. Rammeverket er laget av Google, og er til en viss grad inspirert av Java-verdenen og benytter seg blant annet IoC-mekanismer. AngularJS gir deg en mengde verktøy for å bygge store JavaScript-applikasjoner. Med toveis binding er det mindre jQuery-hacking, og med \"dependency injection\" er det enkelt å teste.I tillegg hjelper Angular deg med å sette opp en god struktur for app-en. Samtidig er det viktig å huske på at Angular både er stort og komplekst, og at det fortsatt er i stor bevegelse. Det er fortsatt få gode ressurser, selv om det begynner å bli bedre. Vi vil helt sikkert fortsette å se vekst i antall prosjekter som bruker rammeverket, men vi tror også at vi etter hvert vil høre mer om prosjekter som opplever negative erfaringer ved å bruke AngularJS.","id":23987,"levelFactor":0.27131278085415167,"levelId":228,"name":"Angular.js","number":59,"sectorFactor":0.83312932632054826,"sectorId":393,"shape":"Circle","size":0},{"description":"HTML5 har god støtte i IE9+ og på mobil, og i tillegg finnes det shims og polyfills for å utvide støtten. Det er en rekke gode JavaScript-API-er i HTML5, blant annet for geolokasjon, canvas og lokal lagring i nettleseren, som vi bruker på en rekke prosjekter idag.","id":23989,"levelFactor":0.318885778431659,"levelId":228,"name":"HTML5","number":60,"sectorFactor":0.42396918430410058,"sectorId":393,"shape":"Circle","size":0},{"description":"CSS3 er godt støttet i IE9+ samt de fleste nettlesere på de store håndholdte plattformene, og det åpner for mange nye muligheter. Media queries, bedre font-støtte, box-sizing: border-box, RGBA og flere andre features er allerede essensielle verktøy. Dersom du har behov for å støtte eldre browsere (typisk IE), bør det primært brukes for \"progressive enhancements\". BEKK benytter CSS3-attributter på de fleste prosjekter.","id":23990,"levelFactor":0.31095874675197011,"levelId":228,"name":"CSS3","number":61,"sectorFactor":0.15211166241628374,"sectorId":393,"shape":"Circle","size":0},{"description":"Store modulbaserte frontendrammeverk, som Sencha Touch og JQuery Mobile, med ferdiglagde moduler for de forskjellige enhetene ble raskt populært etterhvert som alle skulle ha en egen mobilside. Ulempen med disse rammeverkene er at de bestemmer for mye. Vi anbefaler derfor ikke å bruke dem, da de låser både utviklere, designere og forretning inn i en ramme som ikke alltid vil passe, og skreddersøm blir utfordrende.","id":23992,"levelFactor":0.42384611542872225,"levelId":226,"name":"Modulbaserte frontendrammeverk","number":62,"sectorFactor":0.54391485091239711,"sectorId":393,"shape":"Circle","size":0},{"description":"Rammeverk som PhoneGap, Appcelerator Titanium, etc. har som mål å gjøre utviklingen av native mobilapps enklere og kjappere, og med delt kodebase mellom alle støttede plattformer. Selv om dette i utgangspunktet høres bra ut, er vår erfaring at slike applikasjoner ikke kan måle seg med native applikasjoner og at rammeverkene henger igjen med å støtte nye teknologier som blir introdusert på de forskjellige plattformene. Utviklere må fortsatt forholde seg til hvordan de forskjellige plattformene fungerer, og siden man vanligvis leverer en app, må man fortsatt gå gjennom godkjenningsrutinene til de forskjellige app stores.","id":23994,"levelFactor":0.22444087373357063,"levelId":227,"name":"Hybrid-app basert på rammeverk","number":63,"sectorFactor":0.24428050645788879,"sectorId":393,"shape":"Circle","size":0},{"description":"Vi anbefaler å bruke et JAX-RS rammeverk hvis man skal utvikle REST-tjenester i java-verdenen. Disse rammeverkene gjør utviklingen enklere, og kvaliteten blir som regel bedre enn hvis man skal skrive sin egen implementasjon. \u000aDe mest brukte alternativene er RESTeasy, Restlet og Jersey. I våre prosjekter bruker vi vanligvis referanseimplementasjonen, Jersey, og har god erfaring med det. Jersey støtter WADL, har implicit views og XML\/JSON\/JSONP\/ATOM-support. I tillegg integrerer det veldig godt med DI-rammeverk som Spring og Guice.","id":23997,"levelFactor":0.511496853390185,"levelId":228,"name":"JAX-RS","number":64,"sectorFactor":0.74387443426141109,"sectorId":392,"shape":"Circle","size":0},{"description":"Vi opplever at TFS Build Server er mer komplisert enn en byggserver trenger å være. Terskelen for å kunne sette opp et bygg som bygger og tester slik man ønsker, er høy sammenlignet med f.eks. TeamCity. Enkelheten og oversiktligheten i TeamCity gjør at vi mener at man skal avstå fra TFS som byggserver.","id":26222,"levelFactor":0.65518791145631139,"levelId":226,"name":"TFS Build Server","number":65,"sectorFactor":0.913140674298176,"sectorId":390,"shape":"triangle","size":0},{"description":"I kjølvannet av OWIN (Open Web Interface for .NET), en spesifikasjon for kommunikasjon mellom web-applikasjoner og web-servere, har stadig flere alternative webrammeverk dukket opp. Noen av de mest modne er Simple.Web, Nancy og ServiceStack, med hver sine konvensjoner og muligheter. Siden de implementerer OWIN, kan de kjøre på alt som er av plattformer. Noen av rammeverkene er mer lettvekt, eller har andre fordeler som gjør at de bør vurderes som alternativ til standard ASP.NET.","id":26223,"levelFactor":0.42436976663174153,"levelId":227,"name":"Alternative Webrammeverk .NET","number":66,"sectorFactor":0.85861827016197356,"sectorId":393,"shape":"triangle","size":0},{"description":"Det kan virke som om REST\/JavaScript-klienter og single-page-apps er den eneste måten å håndtere GUI på i dag. Det er dog viktig å ikke glemme web-rammeverk på serversiden. Den store fordelen med serverside-rammeverk er at de ikke er avhengig av ressurser på klienten. Applikasjoner som ikke har behov for stor dynamikk i grensesnittet kan med fordel bruke slike rammeverk. De er lette å bruke, og det er enkelt å få web-statistikk. BEKK har valgt å bruke serverside-rammeverk i mange prosjekter den siste tiden. Har man bruk for dynamikk, er det ikke noe problem å inkludere en dynamisk \"pagelet\" på en relativt statisk side.","id":26224,"levelFactor":0.26741652308089781,"levelId":227,"name":"Rendre GUI serverside","number":67,"sectorFactor":0.78689991082432542,"sectorId":393,"shape":"triangle","size":0},{"description":"2014 kan fort bli året der de nye flatene slår gjennom for fullt. Responsivt design har lenge handlet om mobil, nettbrett og desktop. Nå ser vi at kjøleskap, TV-er, smartklokker og biler kommer både med støtte for apps og ofte fullgode nettlesere. Nye flater har oppløsninger fra i underkant av hundre ganger hundre pixler, opp til de nye 4K-TV-ene med 5120x3200. Vi tror ikke denne trenden kommer til å påvirke mange norske virksomheter med det første, men det kan lønne seg å ha de mulighetene og utfordringene det gir i tankene allerede nå.","id":26225,"levelFactor":0.36170204336153633,"levelId":227,"name":"Nye flater","number":68,"sectorFactor":0.56619034571897964,"sectorId":393,"shape":"triangle","size":0},{"description":"Git har allerede tatt utviklingsverdenen med storm. Vi ser også i stadig større grad at Github brukes til kildekontroll – også hos tradisjonelle \"\"enterprise\"\"-bedrifter. Noen er skeptiske til å legge koden sin hos en tredjepart – spesielt utenfor Norge. Skepsisen kan i noen tilfeller være velbegrunnet, men det er viktig å ikke sette seg fast i en forhåndsantagelse om at alt som hostes av en tredjepart er usikkert. Github jobber aktivt med sikkerhet og tilbyr gode administrasjonsgrensesnitt og konfigurasjon for sikkerhet. Dersom det er uaktuelt å legge koden sin hos en tredjepart, kan man vurdere en intern Github-Enterprise-installasjon.\u000aSammenliknet med andre løsninger for versjonskontroll, passer Github sin funksjonalitet for \"\"sosial programmering\"\" utmerket også på interne prosjekter. Muligheten til å diskutere ned på enkeltkodenivå, støtte for README-filer, \"\"Pull Requests\"\" og \"\"Issue Tracking\"\" har allerede blitt en viktig del av arbeidsflyten på mange av våre prosjekter.","id":26226,"levelFactor":0.38657819783033726,"levelId":228,"name":"GitHub","number":69,"sectorFactor":0.800800891533253,"sectorId":390,"shape":"triangle","size":0},{"description":"Digitale samhandlingsverktøy for smidig utvikling har kommet for fullt. Midt i denne trenden synes vi Trello er et godt eksempel på et verktøy som forenkler hverdagen til deltakerne i et utviklingsprosjekt. Trello legger opp til deling og diskusjon som et sentralt aspekt. Vi opplever ofte at fleksbiliteten i dette verktøyet gjør at vi finner nye måter å bruke det på, både internt og i prosjekter.\u000aAnkepunktet mot Trello er at det er forholdsvis funksjonsfattig sammenliknet med f.eks. Jira Agile og Jetbrains YouTrack – spesielt når det kommer til rapportering. Vår erfaring er at det glimrende brukergrensesnittet veier opp for det – og at vi finner andre måter å løse rapporteringen på.","id":26227,"levelFactor":0.13334015134614036,"levelId":228,"name":"Trello for samhandling","number":70,"sectorFactor":0.088551226603570565,"sectorId":390,"shape":"triangle","size":0},{"description":"Det Scala-baserte ytelsestestverktøyet Gatling baserer seg på actor-modellen i Akka. Siden Gatling er skrevet i Scala kan det enkelt kjøres på eksisterende infrastruktur og byggesystemer i Java-miljøer. Actor-modellen i Akka bidrar til at Gatling kan kjøre mye kraftigere tester fra enkle testrigger enn man kan med de fleste av dagens testrammeverk.\u000aNoen vil kanskje være skeptisk til Gatling siden det krever at man skriver testene sine i Scala, men vår erfaring er at Gatling sin DSL er lettlest og enkelt å sette seg inn i. Åpenheten, prisen (gratis!) og fleksibiliteten gjør Gatling til vårt førstevalg blant ytelsestestverktøy. Det negative med Gatling er at det er litt umodent og fortsatt under utvikling. BEKK har likevel god erfaring med Gatling fra flere prosjekter.\u000a","id":26228,"levelFactor":0.82641577839350056,"levelId":227,"name":"Gatling","number":71,"sectorFactor":0.85598442387786688,"sectorId":392,"shape":"triangle","size":0},{"description":"Maven har i mange år vært standard byggesystem på de fleste Java-prosjekter i Norge. Vi bruker selv Maven på bortimot alle Java-prosjekter i BEKK. Samtidig ser vi at det begynner å bli mange andre gode byggesystemer å velge mellom, som det Groovy-baserte Gradle eller Scala-baserte SBT. Alternativene tilbyr mer fleksibilitet og adresserer en del av ulempene med Maven. For nye Java-prosjekter i dag vil vi vurdere å bruke noe annet enn Maven.","id":26229,"levelFactor":0.41345924018174068,"levelId":227,"name":"Alternative byggesystemer","number":72,"sectorFactor":0.94011875822251756,"sectorId":390,"shape":"triangle","size":0},{"description":"Det har etter hvert dukket opp mange spennende programmeringsspråk som kjører på JVM-en. Clojure, Scala og Groovy er alle modne og velprøvde språk som tilfører vesentlig funksjonalitet i forhold til det man finner i ren Java. Selv om man ikke ønsker å gå helt over til et nytt språk, mener vi det vil kunne gi verdi å mikse forskjellige språk på samme prosjekt. Det er ingenting i veien for å skrive en modul i et annet språk enn Java hvis man ser at det gir verdi med tanke på lesbarhet eller andre kryss-funksjonelle aspekter. ","id":26230,"levelFactor":0.48856054147771921,"levelId":227,"name":"Polyglot JVM","number":73,"sectorFactor":0.078654684495691671,"sectorId":392,"shape":"triangle","size":0},{"description":"For JavaScript har vi frem til nå vært avhengig av manuell installering og oppdatering av avhengigheter som jQuery, Backbone og Angular. På backend har vi hatt verktøy som Maven og NuGet til å løse dette, mens vi har hatt npm for Node.js. Det har kommet flere alternativer for JavaScript på frontend, men Bower er uten tvil det verktøyet som har fått den mest sentrale posisjonen. Vi har stor tro på Bower, og bruker det allerede på en rekke prosjekter. Man kan også vurdere å bruke npm som \"package manager\" for frontend JavaScript, for eksempel sammen med Browserify, slik at man kan bruke Node.js-pakker også i nettleseren.","id":26231,"levelFactor":0.70088519712667008,"levelId":227,"name":"Pakkesystem for JavaScript","number":74,"sectorFactor":0.56183443149901835,"sectorId":393,"shape":"triangle","size":0},{"description":"I tillegg til tilnærmet logikkløse template-bibliotek som Mustache og Handlebars, ser vi at flere rammeverk nå tar større kontroll over view-laget, og dermed også over templatene. Angular.js og Ember.js er kjente eksempler på rammeverk med toveis-binding mellom DOM-en og JavaScript-koden. Disse rammeverkene ønsker at man deklarativt spesifiserer oppførsel i templatene og håndterer mye av det vi vanligvis ville gjort med jQuery automatisk i bagrunnen. For biblioteker som Backbone som ikke kontrollerer templatene er det mulig å bruke biblioteker som Ractive.js og React.js som alternativer til Mustache og Handlebars. Vi har stor tro på toveis binding i JavaScript, også utenfor Angular.js og Ember.js.","id":26232,"levelFactor":0.14063837962801551,"levelId":228,"name":"Reactive programming","number":75,"sectorFactor":0.62213897311408572,"sectorId":393,"shape":"triangle","size":0},{"description":"Forskriften for universell utforming av IKT trådte i kraft 1. juli i 2013, noe som betyr at alle nye IKT-løsninger skal være universelt utformet fra 1. juli 2014. At en løsning er fullt ut universelt utformet betyr at den er brukervennlig og tilgjengelig for alle, uavhengig av funksjonsevne. En sentral komponent for å oppnå dette er WAI-ARIA, som er en standard som definerer hvordan applikasjoner og annet nettinnhold i større grad kan gjøres tilgjengelig for de som bruker IKT-hjelpemidler. WAI-ARIA er et sett med attributter som settes på HTML-elementer, og som fungerer som et ekstra lag med semantiske metadata. Disse er i dag støttet i de aller fleste nettlesere, og WAI-ARIA er et sentral hjelpemiddel for universell utforming. Vi anbefaler å benytte WAI-ARIA i alle nye prosjekter.","id":26233,"levelFactor":0.527239099185757,"levelId":228,"name":"WAI-ARIA","number":76,"sectorFactor":0.17558348837706159,"sectorId":393,"shape":"triangle","size":0},{"description":"Med rike grensesnitt og mange web-applikasjoner som har delvis likt utseende og funksjonalitet, er det ønskelig å kunne dele HTML, CSS, JavaScript og statiske filer som fonter og bilder på tvers av prosjekter internt i en organisasjon. Med verktøy som Bower og npm er dette nå blitt mye enklere. Vi tror dette vil være et av de sentrale områdene vi vil se mye aktivitet i tiden fremover, og vi ser allerede mye interesse på flere prosjekter.","id":26234,"levelFactor":0.88255537375133586,"levelId":227,"name":"Distribuerte frontend-komponenter","number":77,"sectorFactor":0.75492851636622937,"sectorId":393,"shape":"triangle","size":0},{"description":"Det har skjedd mye interessant med og i Node.js de siste årene. Store aktører som Paypal, LinkedIn og GroupOn hatt stor suksess med å ta det i bruk, i tillegg til at Node.js sitt pakkesystem, npm, har hatt en enorm vekst de siste årene. Etter hvert som JavaScript-kompetanse er et must på klientsiden, er det en besnærende tanke å kunne bruke JavaScript gjennom hele stacken ned til et JSON\/REST-basert datalager. I mange tilfeller er det ikke nødvendig med Java\/.NET på serversiden, og da er Node.js et godt alternativ. Det er også en generell trend at applikasjonene blir mindre (\"\"micro services\"\"). I den forbindelse kan det være nyttig å vurdere Node.js som plattform på applikasjoner med lite integrasjon og med behov for å kunne håndtere mange og\/eller langtlevende forespørsler. \u000aI BEKK har vi tro på Node.js, men det er nok fortsatt et lite stykke igjen til bred adopsjon for Node.js på serveren.","id":26235,"levelFactor":0.1992363802674329,"levelId":227,"name":"Node.js serverside","number":78,"sectorFactor":0.047205050326236689,"sectorId":392,"shape":"triangle","size":0},{"description":"For å unngå dypt nøstede callbacks, bruker vi i stadig større grad promises for asynkronitet i JavaScript. Standardiseringen av promises, kalt Promises\/A+, har kommet langt og vi vil etterhvert få native promises i JavaScript. Mens vi venter på native støtte, er det derimot en rekke biblioteker vi kan bruke for promises, blant annet anbefaler vi jQuery, Q og RSVP.js","id":26236,"levelFactor":0.82941148597914338,"levelId":227,"name":"Promises for asynkronitet","number":79,"sectorFactor":0.45112549605560526,"sectorId":392,"shape":"triangle","size":0},{"description":"Java EE tilbyr standardiserte tekniske tjenester for applikasjoner. Denne standardiseringen gir forutsigbarhet på bekostning av valgfrihet og fleksibilitet. Vi ser nå i større grad at java-applikasjoner er skreddersydde på grunn av mer varierte funksjonelle krav enn tidligere, og at de tekniske tjenestene som trengs i større grad bakes med i applikasjonene. Ved å pakke en lettvekts appcontainer og applikasjonen i samme fil, oppnår man en totalpakke som tar ansvar for både de funksjonelle behov og de tekniske tjenestene. Dette forenkler deployment og gir større fleksibilitet med tanke på skalerbarhet og redundans. En embedded appcontainer gjør det også enklere å kjøre helt likt oppsett av appcontainer og applikasjon i alle miljøer, som bidrar til å redusere risiko og kompleksitet i overleveringer fra utvikling til produksjonsmiljø. Vi benytter embedded appcointers i mange av våre prosjekter","id":26237,"levelFactor":0.56624528395815854,"levelId":228,"name":"Embedded appcontainer","number":80,"sectorFactor":0.30080089153325296,"sectorId":391,"shape":"triangle","size":0},{"description":"Med virtualisering på operativsystemnivå, tillater systemets kernel flere isolerte container-instanser som oppfattes som ekte servere fra brukerens synspunkt. Dette skiller seg fra virtuelle maskiner ved at operativsystemets normale systemkall og kernel benyttes, og har liten eller ingen overhead. Dette gir mulighet for å deploye komplette lettvekts kjøretidsmiljø for applikasjoner der konfigurasjonen er skreddersydd og ikke påvirker operativsystemet eller andre containere. Man kan teste ut konfigurasjonsendringer uten at det påvirker andre, og inkludere hele plattformen i kontinuerlig integrasjon og testing. I produksjon har man full kontroll på sin egen gjennomtestede konfigurasjon. Linux containers, som LXC og Docker, er veldig godt egnet til å lage PaaS-løsninger. Metoden introduserer noen sikkerhetsproblemstillinger som må tenkes nøye gjennom ved bruk. Foreløpig har vi ikke tatt dette i bruk i produksjon, men det er en teknologi vi følger tett og bygger kompetanse på.","id":26238,"levelFactor":0.44743746998768441,"levelId":227,"name":"Linux Containers","number":81,"sectorFactor":0.21892064068236336,"sectorId":392,"shape":"triangle","size":0},{"description":"I mange applikasjoner blir det vurdert å ta i bruk en regel- eller prosessmotor for å håndtere hhv forretningsprosesser og forretningsregler. Ved å skille disse fra applikasjonen, forventer man gjerne å oppnå enkel utvikling og forvaltning, å enkelt kunne endre dem i en kjørende applikasjon, og å overlate forvaltning og oppsett av dette til forretningssiden i organisasjonen. Vi har imidlertid opplevd at applikasjonene i stor grad må tilpasses disse motorene, som medfører kompleksitet og økte kostnader ved utvikling, integrasjon og utrulling. Det er viktig å passe på at regel- eller prosessmotoren spiller på lag med kontinuerlig automatisk testing og utrulling, og være forberedt på at man må bruke tid på å plassere ansvar for vedlikehold av reglene og prosessene i organisasjonen. I mange tilfeller vil regler og prosesser være enkle å implementere, endre og teste i selve applikasjonen, og vi forsøker gjerne det før vi vurderer å ta i bruk en regel- eller prosessmotor.","id":26239,"levelFactor":0.70562781007735731,"levelId":226,"name":"Regel- og prosessmotor","number":82,"sectorFactor":0.66133498909485589,"sectorId":391,"shape":"triangle","size":0},{"description":"Med en kombinasjon av moderne søketeknologi (Elastic Search, Neo4J osv.) og JavaScript-basert visualisering kan man lage ekstremt kraftige skreddersydde verktøy for analyse og overvåkning av data som kan overgå det tradisjonelle datavarehuset i ytelse og nytteverdi. Vi mener at man i mange tilfeller kan svare på de samme spørsmålene som datavarehuset på en vesentlig billigere og raskere måte med smart bruk av enkle verktøy. ","id":26240,"levelFactor":0.64215981210789,"levelId":227,"name":"Skreddersydd datavarehus","number":83,"sectorFactor":0.5126046847886333,"sectorId":391,"shape":"triangle","size":0},{"description":"Horisontal skalering innebærer å sette opp flere instanser av samme applikasjon til forskjell fra vertikal skalering hvor man utvider ressursene til en instans. Horisontal skalering kan være en enkel og billig måte å skalere på, og i mange tilfeller kan det gjøres idet behovet melder seg ved kjøretid. Det krever imidlertid at applikasjonen utvikles med dette for øyet. Applikasjoner med små og uavhengige tjenester, feiltoleranse og mindre grad av tilstand kan kan forenkle horisontal skalering, sammen med automatisert utrulling og benyttelse av PaaS. og\/eller IaaS-løsninger. Vår erfaring er at applikasjoner som lar seg skalere horisontalt ofte er enkelere å forvalte og drifte enn applikasjoner som må skaleres vertikalt.","id":26241,"levelFactor":0.31826745524601935,"levelId":228,"name":"Horisontal skalering","number":84,"sectorFactor":0.87904969939268074,"sectorId":391,"shape":"triangle","size":0},{"description":"Vi opplever at mange prosjekter leveres uten å ta hensyn til langsiktige arkitekturmålbilder, eller prosjektene gjøres så store at de omfatter hele målbildet. Dette medfører ofte enten til løsninger som bryter med langsiktige målbilder, eller man får veldig store prosjekter med de utfordringer det medfører. En bedre fremgangsmåte er å arbeide mot de langsiktige målbildene ved å definere transisjonsarkitekturer. Transisjonsarkitekturene er milepæler og delmål som ivaretar retning og bevissthet på veien mot det langsiktige målbildet. Prosjektene leverer så disse transisjonarkitekturene. Vi har god erfaring med definering av målbilder og transisjonsarkitekturer og opplever at dette sikrer at prosjekter og leveranser bidrar til å bevege seg mot, og ikke bort fra, langsiktige mål og strategier.","id":26242,"levelFactor":0.7505048442171095,"levelId":228,"name":"Transisjonsarkitektur","number":85,"sectorFactor":0.29516723530086658,"sectorId":391,"shape":"triangle","size":0},{"description":"Solr er Elasticsearch sin litt eldre og mer erfarne fetter og er også basert på Lucene. Solr har innebygget funksjonalitet som dekker svært mange av de vanlige kravene forbundet med fritekstsøk - spesielt språkstøtte og fasettering. Solr takler store datamengder, har svært god ytelse, tilbyr ulike klient-APIer og dataformater, og er lett å ta i bruk. I de fleste tilfeller anbefaler vi dog Elasticsearch framfor SOLR","id":26243,"levelFactor":0.10129268484729669,"levelId":228,"name":"SOLR","number":86,"sectorFactor":0.31692354007013374,"sectorId":392,"shape":"triangle","size":0},{"description":"I dagens NoSQL-landskap finnes det databaser som kan løse omtrent hvert tenkelige problem, men svært sjelden kan komplekse problemstillinger løses med kun én databaseteknologi. Vi ser oftere og oftere at forskjellige persisteringsteknologier brukes i våre prosjekter. Et eksempel kan være dokumentdatabase for ustrukturerte data, som f.eks. kunde- og brukerregister, grafdatabase for kjøpsanbefalinger og en relasjonsdatabase for produktkatalog. Fordelen ved en polyglot-persistence-tilnærming er at man sjeldnere trenger å gå på kompromiss med datamodellen sin og bruker rett verktøy på rett sted.","id":26244,"levelFactor":0.4169054531232293,"levelId":227,"name":"Polyglot persistence","number":87,"sectorFactor":0.13271307987162595,"sectorId":391,"shape":"triangle","size":0},{"description":"Ende-til-ende-rammeverk som Ruby on Rails, ASP.NET, Grails, Django og Play tar seg av alle deler av en webapp, fra lagring i database, forretningslogikk, kontroller-logikk og visning. På engelsk kalles disse også \"full stack frameworks\". Disse gjør det mulig å lage små webapper på rekordtid. Men det er ikke nødvendigvis det beste langsiktige valget for større applikasjoner. Prosjekter bør gjøre en grundig vurdering før de låser seg til et ende-til-ende-rammeverk. Man blir avhengig av utviklerkompetanse, og det blir vanskelig å bytte ut lag eller komponenter i løsningen når alt er så integrert.","id":26245,"levelFactor":0.14449951378636358,"levelId":227,"name":"Ende-til-ende-rammeverk","number":88,"sectorFactor":0.44727889771715,"sectorId":392,"shape":"circle","size":0},{"description":"En logg-aggregator samler informasjonen i applikasjons- og serverlogger over forskjellige maskiner, applikasjoner og miljø. Prosjekter med stor trafikk bør vurdere å bruke slike aggregatorer som et supplement til de filbaserte råloggene. De er uvurderlige når man får inn hastesaker om feil i produksjon, og gjør det mulig for utviklere å respondere fort. Man kan også tilpasse visningen til forskjellige bruksområder som overvåkning, debugging eller statistikk. Vi har hatt god erfaring med dette i store applikasjoner med hundretusenvis av brukere hver dag. Det kommersielle alternativet Splunk er kraftig, men har en aggressiv lisensmodell. Det finnes gode alternativer, som logstash, og å ha en logg-aggregator er stort sett bedre enn å ikke ha en. I BEKK har vi brukt logg-aggregatorer  i mange prosjekter.","id":26246,"levelFactor":0.85116558000954712,"levelId":227,"name":"Logg-aggregator","number":89,"sectorFactor":0.780952283163355,"sectorId":390,"shape":"triangle","size":0},{"description":"Functional Reactive Programming (FRP) henter det beste fra funksjonell, event-drevet og deklarativ programmering. Dette bør vurderes som en teknikk i GUI-intensive applikasjoner hvor man må reagere på handlinger eller aggregere kompositter av hendelser. I FRP vil en strøm av hendelser (datatyper med verdier avhengig av tid) kunne behandles som sekvenser med funksjonell kode som implementerer de ønskede resultatene. Fordelene er blant annet fokus på deklerativitet, rask respons for brukeren, gode muligheter for kompositter\/DRY og kode som er enklere å analysere. Nye (compile-to-Javascript) programmeringsspråk som Flapjax\/Elm baserer seg på denne teknikken, men det finnes også JS-implementasjoner som Bacon.js. Det finnes også gode muligheter for reaktiv programmering i C# og Java med f.eks Reactive Extensions som tilater propagering av datatyper og gjør at en kan designe hendelsesdrevne og responsive applikasjoner som skalerer.","id":26247,"levelFactor":0.41350175263190531,"levelId":227,"name":"Functional Reactive Programming","number":90,"sectorFactor":0.8014701954103991,"sectorId":392,"shape":"triangle","size":0},{"description":"Det finnes en rekke språk eller språkutvidelser som kompilerer ned til standard JavaScript. Hvor langt språket ligger fra JavaScript varierer. TypeScript og CoffeScript er forholdsvis små utvidelser, mens ClojureScript og Dart er helt nye språk. Sweet.js er ikke et nytt språk i seg selv, men gir JavaScript macro-støtte, noe som gjør det mulig å utvide JavaScript med nye egenskaper. For eksempel er det mulig å bruke et sett med makroer som lar deg bruke ECMAScript 6 i dag, samtidig som koden kompilerer ned til vanlig JavaScript. Microsofts TypeScript er et supersett av JavaScript, som utvider språket med valgfri statisk typing, samt flere andre egenskaper fra ECMAScript 6.  CoffeScript derimot tar mye av inspirasjonen fra Python, Rybu og Haskell, og innfører mange nyttige forenklinger og forbedring. Felles for alle pre-kompilatorene er at de begynner å bli modne og raske. Ved hjelp av source-map filer er det mulig å knytte kompilert JavaScript opp mot originalkoden ved debugging. I mange av våre prosjekter bruker vi byggeverktøy for front-end kode (se eget punkt i radaren), noe som gjør det enkelt å legge en pre-kompilator inn i byggeprosessen.  ","id":26248,"levelFactor":0.49738656117442159,"levelId":227,"name":"Prekompilator for JavaScript","number":91,"sectorFactor":0.43538192745009707,"sectorId":393,"shape":"triangle","size":0},{"description":"Passord som eneste autentiseringsfaktor synes i større og større grad å være utilstrekkelig. Vi har de siste årene sett eksempler på store nettsteder som har fått sin brukerdatabase på avveie, og dessverre er det slik at mange gjenbruker passordene sine på tvers av tjenester. Lister over de mest brukte passordene viser også at passordkvaliteten er relativt lav.\u000aTOTP er en enkel løsning for å kunne benytte mobilen som en ekstra faktor i autentiseringen. TOTP er støttet på store nettsteder som Google, Facebook, Dropbox og Github, og TOTP er støttet gjennom applikasjoner på alle de store mobilplattformene. Selv om dette ikke er på samme nivå som for eksempel BankID, gir det betydelig høyere sikkerhet enn kun passord. Det er også svært enkelt å implementere og det finnes gode kodeeksempler på nett.","id":26249,"levelFactor":0.35377018403419597,"levelId":228,"name":"TOTP","number":92,"sectorFactor":0.33679125807424032,"sectorId":391,"shape":"triangle","size":0},{"description":"Vi har hatt stor suksess med en hybrid variant med varierende grad av native og web-basert innhold. Forretningskritisk funksjonalitet gjøres da tilgjengelig i et web view, slik at denne kan endres og oppdateres, uten at bruker må oppdatere sin applikasjon. På denne måten sikrer man at alle som bruker applikasjonen får oppdatert funksjonalitet, og mulige sikkerhetsfeil blir håndtert utenom appen, slik at faren for utnyttelse blir mindre. I tillegg blir man synlig i app store, og kan utnytte innebygd lagring og funksjonalitet i telefonen der hvor det er naturlig.","id":26250,"levelFactor":0.1259764361346358,"levelId":228,"name":"Hybrid-app med integrert web view","number":93,"sectorFactor":0.081493097793518765,"sectorId":393,"shape":"triangle","size":0},{"description":"Det er fortsatt normen at et produksjonsklart system blir overlevert til en driftsorganisasjon for utrulling og overvåkning. Det oppstår gjerne konflikter mellom forretnings- og utviklingssidens behov for endringer og feilrettinger vs driftsorganisasjonens ønske om en stabil plattform. Ofte ivaretas krav om driftbarhet dårlig i utviklingsløpet, noe som skaper ytterligere belastning på samarbeidet.  Vi mener DevOps-tankegangen bør være en sentral vurdering når man ser på modernisering av driftsregimet. ","id":26254,"levelFactor":0.65978755841031544,"levelId":226,"name":"Utvikling-drift-separasjon ","number":94,"sectorFactor":0.72640483570929315,"sectorId":390,"shape":"circle","size":0},{"description":"Automatisert bygging og kjøring av testene har i lang tid vært populært på backend-tunge applikasjoner. Automatisert bygging kan også gi stor verdi for mobilapplikasjoner. Man kan slutte å sende ut produksjons-sertifikater til forskjellige utviklere, da den automatiserte byggeprosessen bygger den versjonen som skal sendes til App Stores. I tillegg kan man bygge forskjellige versjoner eller applikasjoner som går mot forskjellige testmiljøer. Da Apple lanserte Bots, gjorde de helt klart denne prosessen enklere i iOS-verdenen, mens Android har alltid hatt god terminalstøtte for å bygge applikasjoner. Windows Phone ligger litt etter på dette feltet, men det er mulig å få til.","id":26255,"levelFactor":0.10550551675631344,"levelId":228,"name":"Automatisert bygging av mobilapplikasjoner","number":95,"sectorFactor":0.3776240789960954,"sectorId":393,"shape":"triangle","size":0},{"description":"Dette er en samlebetegnelse på de små maskinene som har begynt å vokse frem i nyere tid. Vi bruker mikromaskin som betegnelse på små datamaskiner som i praksis kan gjøre det samme som en vanlig PC – bare at den tar mye mindre plass. Disse maskinene kjører full-blåste operativsystemer, vanligvis av Linux-varianten. Den mest kjente mikromaskinen er Raspberry Pi. Et prototypebrett er som regel litt “nærmere jernet” enn en mikromaskin. Det vil si at de kommer uten fullt operativsystem og krever mer elektronikk-kunnskaper for utvikling. Italienske Arduino er til nå det mest populære prototypebrettet.\u000aDette er ikke teknologi som er mye i bruk i kundeprosjekter per dags dato, men vi ser et stort potensiale der man trenger små, strømgjerrige og billige maskiner. Dette kan for eksempel strømavlesing, værmåling, styring av skjermer, kameraer og annet utplassert utstyr. BEKK bygger mye kompetanse på dette området og ser masse spennende hobbyprosjekter som for eksempel hjemmelagde værstasjoner, busstavler og bryggemaskiner.","id":26256,"levelFactor":0.45938866281861829,"levelId":227,"name":"Mikromaskiner og prototypebrett","number":96,"sectorFactor":0.6135362702397773,"sectorId":391,"shape":"triangle","size":0},{"description":"Wearables er en betegnelse for datamaskiner du kan bære på kroppen. Etterhvert som man klarer å putte mer teknologi inn i stadig mindre maskiner er potensialet her enormt. Så langt har vi blant annet sett wearables som en enkel utvidelse av mobilen, innen treningsutstyr og innen helsesektoren. Som utvidelse til mobiltelefonen har Android har allerede lansert Android Wear som er deres teknologi for smartklokker. Apple har fortsatt ikke lansert noe, men ryktene sier at iWatch er rett rundt svingen. I tillegg har blant andre Pebble, Sony og Samsung kommet med klokker. Dette er et område der det allerede har begynt å skje ting i Norge. \u000aDet er forventet at smartklokker kommer til å ta av i løpet av kort tid, og mange ønsker å være tidlig ute med å ha mobil-apper som kan benytte seg av smartklokken som en utvidelse. \u000aWearables innen helse har et enormt potensiale. Tenk automatisk overvåkning av blodtrykk, insulinnivå og alle andre tenkelige og til nå utenkelige aspekter av livet og helsen vår. Dette har fortsatt til gode å ta av i Norge, men vi er ikke i tvil om at dette kommer også her til lands.","id":26257,"levelFactor":0.91641814032514035,"levelId":227,"name":"Wearables","number":97,"sectorFactor":0.27575788111131461,"sectorId":393,"shape":"triangle","size":0},{"description":"Xamarin for iOS og Android, tidligere MonoTouch og Mono for Android, lar utviklere lage apper for Windows 8, iOS og Android i C#\/.NET. Dette åpner for stor grad av gjennbruk av kode på tvers av plattformene, samtidig som brukeropplevelsen er 100% \"native\". Det er imidlertid viktig å være klar over at ved bruk av rammeverk for x-plattform, må man fortsatt forholde seg til teknologiene bak iOS, Android og WP. Det kommer i tillegg til at man gjør seg avhengig av et nytt 3-parts rammeverk.","id":26258,"levelFactor":0.45978611645703787,"levelId":227,"name":"Xamarin","number":98,"sectorFactor":0.702365258558095,"sectorId":393,"shape":"circle","size":0}],"published":"True","sectors":[{"id":390,"index":0,"name":"Prosess og kvalitet"},{"id":391,"index":1,"name":"Arkitektur og plattform"},{"id":392,"index":2,"name":"Språk og rammeverk"},{"id":393,"index":3,"name":"Frontend og mobil"}],"startDate":"\/Date(1371938400000+0200)\/","updateDate":"\/Date(1444809932650+0200)\/","url":"techradar2014"}
