{"description":"BEKKs Teknologiradar som ble publisert juni 2013.","displayDate":null,"history":"False","id":66,"ingress":null,"levels":[{"id":206,"name":"Avstå","radius":0},{"id":207,"name":"Vurder","radius":0.1746556411669149},{"id":208,"name":"Bruk","radius":0.502090538150211}],"name":"BEKKs Teknologiradar 2013","numLevels":0,"numPoints":0,"numSectors":0,"oldurl":null,"plugins":[{"id":61,"url":"Scripts\/Plugins\/default.js"}],"pointInfos":[],"points":[{"description":"I flytbaserte prosesser, som Kanban er et eksempel på, underordnes kort- og langsiktig planlegging av en kontinuerlig flyt av oppgaver, der forretningssiden fortløpende kan legge til, fjerne og reprioritere oppgaver. Det benyttes gjerne teknikker for å bryte opp eller aggregere krav til oppgaver av enhetlig størrelse, i stedet for å estimere. Nøkkelen er å finne en forretningsmessig riktig balanse mellom utførelsestid og gjennomstrømning av oppgaver, og harde grenser for mengden varer i arbeid kan være en måte å oppnå det på. En oppgave er ikke ferdig før den er i produksjon, så det bør sees i sammenheng med kontinuerlige leveranser. I BEKK foretrekker vi ofte flytbaserte metoder over tidsboksbaserte metoder som Scrum - spesielt i forvaltningsprosjekter.","id":18389,"levelFactor":0.194056967639734,"levelId":208,"name":"Kanban","number":1,"sectorFactor":0.24223788318168679,"sectorId":312,"shape":"Circle","size":0},{"description":"Mange assosiserer \"smidig\" med tidsboksbaserte utviklingsmetodikker, og i Norge er det Scrum som dominerer. Prosjektet deles opp i korte leveransesykler, typisk 2 eller 3 uker, og etter hver sykel skal teamet levere en produksjonsklar løsning som oppfyller produkteiers høyest prioriterte krav. Scrum, med sine klare roller og regler, egner seg godt for organisasjoner som har begrenset erfaring med smidig utvikling, og som trenger å inkorporere smidig i en mer klassisk prosjektsetting. Mer modne organisasjoner kan vurdere å gå rett til flytbaserte prosesser, også for nyutvikling.","id":18390,"levelFactor":0.68639402259030546,"levelId":207,"name":"Scrum","number":2,"sectorFactor":0.69893830562497994,"sectorId":312,"shape":"Circle","size":0},{"description":"DevOps er en samlebetegnelse for tiltak som bygger bro over det tradisjonelle gapet mellom softwareutviklere på den ene siden, og drifts- og infrastrukturspesialister på den andre. Dette har blitt relevant på grunn av behov for hyppigere og billigere utrulling av endringer, samt økt utbredelse av verktøy og plattformer som gjør dette enklere, f.eks. PaaS\/IaaS og rammeverk for automatisert utrulling og testing. I BEKK løser vi DevOps-utfordringen ved en kombinasjon av at utviklingsteamet tar ansvar for en større del av infrastruktur, konfigurasjon, utrulling og monitorering, og at driftspersonell trekkes tettere og tidligere inn i utviklingsløpet.","id":18391,"levelFactor":0.1907334771176569,"levelId":208,"name":"DevOps","number":3,"sectorFactor":0.70004624006570426,"sectorId":312,"shape":"Circle","size":0},{"description":"Hyppige leveranser reduserer risiko ved produksjonssettinger betraktelig. Når det er færre ting som går i produksjon om gangen, har man bedre oversikt over hva som har endret seg og hva som bør testes. Dette minsker behovet for omfattende regresjonstesting, og det er lettere å fikse eventuelle feil fordi man har god oversikt over hva som har endret seg. Når du leverer kontinuerlig, bør du ikke ha nedetid for hver produksjonssetting. Dette kan for eksempel løses for en web-applikasjon ved å persistere sesjoner i databasen, melde en node ut av clusteret, oppgradere denne, melde den inn i clusteret igjen og repetere for hver node. Databasemigrering kan løses ved hjelp av \"expand\/contract\"-mønsteret (se Automatisert migrering\/rollback av database).","id":18392,"levelFactor":0.47078502479519119,"levelId":208,"name":"Kontinuerlige leveranser","number":4,"sectorFactor":0.51157362973344411,"sectorId":312,"shape":"circle","size":0},{"description":"Noen av de mest innovative kundene våre benytter en modell der team fra flere leverandører i en avgrenset periode konkurrerer om å levere en prototype på en løsning av et forretningsproblem. En slik \"proof-of-concept\" (PoC) har gjerne noen ukers varighet, men vi har avsluttet PoC'er med fullt kjørende løsning på under en uke. Kundens fordel er at ulike teknologiske plattformer og fremgangsmåter kan testes ut - og sammenlignes - i realistiske omgivelser. Dette er etter vår mening en vinn-vinn-modell der det genereres langt mer og bedre informasjon enn i en typisk anbudsprosess, og der leverandørene får et klarere bilde av kunden og dens behov enn hva anbudsdokumenter formidler. Vi hadde gjerne sett at en PoC ble grunnlaget for valg av teknologi og leverandør og skled rett over i et inkrementelt fianansiert utviklingsløp. Vi ser gode eksempler på dette i både privat og offentlig sektor, og blant annet i Danmark er det gjort flere forsøk. Vi har tro på at man også innenfor det offentlige anskaffelsesregelverket kan finne modeller som åpner for denne typen prosesser.","id":18393,"levelFactor":0.56146612108964467,"levelId":207,"name":"Smidig anskaffelse","number":5,"sectorFactor":0.43923227810986731,"sectorId":312,"shape":"Circle","size":0},{"description":"Fortsatt blir mange systemutviklingsløp kjørt med en prosjektfase etterfulgt av en overlevering til en forvaltningsenhet i linjeorganisasjonen. I praksis bør det være en glidende overgang mellom nyutvikling og forvaltning, spesielt om man gjør hyppige leveranser. I BEKK oppnår vi høy produktivitet og gode resultater i kundeengasjement hvor skillet mellom prosjekt og forvaltning fjernes. Ressurser fra linjeorganisasjonen bør være med fra dag én og gradvis erstatte prosjektressurser helt, heller enn å gjøre en engangs overlevering fra prosjekt til linje.","id":18394,"levelFactor":0.84877687305322436,"levelId":206,"name":"Prosjekt-linje-organisering","number":6,"sectorFactor":0.32243425390672292,"sectorId":312,"shape":"Circle","size":0},{"description":"Det er fortsatt normen at et produksjonsklart system blir overlevert til en driftsorganisasjon for utrulling og overvåkning. Det oppstår gjerne konflikter mellom forretnings- og utviklingssidens behov for endringer og feilrettinger og driftsorganisasjonens ønske om en stabil plattform. Ofte ivaretas krav om driftbarhet dårlig i utviklingsløpet, noe som skaper ytterligere belastning på samarbeidet. DevOps-tankegang er et middel for å redusere denne ubalansen.","id":18395,"levelFactor":0.64966548585733142,"levelId":206,"name":"Utvikling-drift-separasjon ","number":7,"sectorFactor":0.73249845744020048,"sectorId":312,"shape":"circle","size":0},{"description":"I BEKK ser vi stadig at mindre prosjekter med ett til to små, dedikerte og tverrfaglige team resulterer i høy produktivitet og leveranser med høy kvalitet. Store prosjekter setter store krav til koordinering og kommunikasjon, noe som øker risiko og kostnad. Det bør være en viktig prosjektledelse- og arkitekturjobb å få brutt ned mega-prosjekter til mindre (del-)prosjekter som kan leveres mer uavhengig av hverandre – også i situasjoner der lovverk, finansieringsmodell eller andre rammebetingelser krever at prosjektene organiseres i store programmer.","id":18396,"levelFactor":0.2533780729124383,"levelId":207,"name":"Mega-prosjekter","number":8,"sectorFactor":0.41635983208421895,"sectorId":312,"shape":"Circle","size":0},{"description":"Funksjonelle team innebærer å ha ulike grupperinger\/avdelinger som håndterer avgrensede oppgaver knyttet til leveranser. Eksempler på grupperinger er test-\/QA-avdeling, virksomhetsarkitekt\/arkitekturråd, og driftsavdeling. Selv om det er fordeler med å holde kompetanseområder sammen, så blir ofte konsekvensen at artefakter overleveres sekvensielt mellom teamene, og informasjon og kontekst går tapt i overleveringen. Utførlig dokumentasjon trengs for å bygge bro mellom grupperingene, men selv da oppstår misforståelser og informasjonshull, og tilbakemelding tar lang tid. Det er som regel mer effektivt å samlokalisere alle som bidrar til leveransene, og la koordinering mellom funksjonelle ressurser innenfor et område ha lavere prioritet og\/eller løses gjennom egne samlinger\/møter utenfor leveranseteamet.","id":18397,"levelFactor":0.16555955834400266,"levelId":207,"name":"Funksjonelle team","number":9,"sectorFactor":0.65838500798029631,"sectorId":312,"shape":"Circle","size":0},{"description":"Et team der ressursene sitter geografisk spredt, er en krevende øvelse. Kommunikasjonsbåndbredden blir som regel svært lav, og dette øker kostnad og risiko. I den grad det er mulig, bør løsningen splittes funksjonelt og teknisk, slik at deltagere internt på hver lokasjon kan jobbe uavhengig av hverandre i så stor grad som mulig.","id":18398,"levelFactor":0.51263794054812006,"levelId":206,"name":"Virtuelle team","number":10,"sectorFactor":0.16290608609565826,"sectorId":312,"shape":"Circle","size":0},{"description":"Automatisert oppsett og utrulling gir raskere og mer smertefri utrulling, noe som spesielt er viktig under utvikling og oppsett av nye miljøer. Dette er samtidig en forutsetning for hyppige produksjonssettinger. Automatikk kan også i stor grad brukes ved oppsett av lokale utviklermaskiner\/miljø, og lokal utrulling bør bruke samme prosess som utrulling til andre miljøer. Dette sikrer at utrullingsrutinene er feilfrie og fungerer som tenkt hver gang.  Fleksibel infrastruktur i form av IaaS-\/PaaS-løsninger kan være til hjelp ved oppsett av automatiske løsninger, men er strengt tatt ingen forutsetning. Et annet aspekt er at rollback av både applikasjon og database bør fungere på samme måte. Det bør finnes et sett av røyktester som kan verifisere at en løsning fungerer som den skal etter både deploy og eventuell rollback. Manuelle steg (med unntak av selve initieringen) bør unngås, da dette på et eller annet tidspunkt vil komme til å feile. ","id":18399,"levelFactor":0.74621535940377526,"levelId":207,"name":"Automatisert oppsett og utrulling","number":11,"sectorFactor":0.13920897454612788,"sectorId":312,"shape":"Circle","size":0},{"description":"Byggekjeder bør benyttes for å visualisere og kvalitetssikre alle stegene i en utrullingsprosess. Artefakter på vei fra utvikling og mot produksjonssetting, bør tvinges gjennom et sett med kvalitetssikringsledd, og prosessen bør være så automatisert som overhodet mulig. Vanlige ledd i en slik kjede kan være enhetstester, funksjonelle tester, dynamiske og statiske kodeanalyser, mutasjonstester, integrasjonstester, sikkerhetstester, ytelsestester, pakking, installering og produksjonssetting. Byggekjeden kan også inneholde manuelle steg, som for eksempel manuelle akseptansetester. De fleste CI-servere støtter nå byggekjeder.","id":18400,"levelFactor":0.72518969551095858,"levelId":207,"name":"Byggekjede","number":12,"sectorFactor":0.87699774913400708,"sectorId":312,"shape":"Circle","size":0},{"description":"Også endringer i en database skal være underlagt versjonering. For Java anbefaler vi å bruke verktøy som Flyway eller Liquibase for å få til dette. Begge verktøyene har bred støtte og er brukt hos mange av våre største kunder. Migrator.NET er modent rammeverk for .NET-verdenen. Endringer i skjemaer bør skriptes inkrementelt, og du bør hele tiden ha mulighet for å kunne refaktorere og behandle skjemaet på samme måte som kode. Bruk versjonskontroll og sørg for å lage og teste rollback-kode. For å støtte utrulling av skjema-endringer uten nedetid kan mønsteret \"expand\/contract\" tas i bruk. Dette innebærer først å legge ut skjema-oppdateringer som vil fungere sammen med både eksisterende og neste versjon av applikasjonen, og så å gjøre endringer\/oppdateringer som spisser skjemaet til å fungere med ny versjon først etter at den nye versjonen er produksjonssatt og stabil. Som et eksempel, kan Liquibase brukes til å verifisere at det har blitt skrevet kode for rollback og at skriptene er korrekte. Hver release kan så tagges med versjonsnummer i metadata-tabeller i databasen, og man kan da rulle frem og tilbake mellom versjoner med en enkel kommando.","id":18401,"levelFactor":0.21111896520684492,"levelId":208,"name":"Automatisk migrering\/rollback av database","number":13,"sectorFactor":0.5,"sectorId":312,"shape":"Circle","size":0},{"description":"Når du bruker et provisjoneringsrammeverk, beskriver du i kode hvordan infrastrukturen din skal se ut. Hvis du ønsker å utføre endringer eller dersom noe feiler, kan du enkelt modifisere koden, og rammeverket vil så konfigurere infrastrukturen på nytt. Dette bidrar til at alle miljøer blir like, konfigurasjonen blir selvdokumenterende, og du kan så refaktorere og inkrementelt forbedre infrastrukturen din. I tillegg blir det lett å klone opp en ny maskin eller et nytt miljø. Infrastrukturoppsettet kommer da under versjonskontroll og du kan også automatisere tester av infrastrukturen.  Det finnes mange gode provisjoneringsrammeverk, men de mest brukte i BEKK er Puppet og Chef.","id":18402,"levelFactor":0.70474955295177955,"levelId":207,"name":"Provisjoneringsrammeverk","number":14,"sectorFactor":0.30871368535007576,"sectorId":312,"shape":"Circle","size":0},{"description":"\"Feature toggling\" sørger for at du enkelt kan skru av og på funksjonalitet i produksjon. Dette implementeres ved å omgi funksjonalitet med konfigurasjonsstyring og å gjøre den tilgjengelig ved hjelp av et flagg. Dette er nyttig dersom en feilsituasjon skulle oppstå, eller man ønsker å skille utrullingstidspunkt fra et lanseringstidspunkt. Det brukes også til delvis utrulling og testing av funksjonalitet - for eksempel for A\/B-testing eller for analyse utført av utviklingsteamet. På den måten kan man gjøre utforskning av en kjørende løsning i et produksjonsmiljø med lav risiko, og det er vanlig og uproblematisk at produksjonskodebasen inneholder uferdig kode. \"Feature toggling\" brukes også som et alternativ til, eller i tillegg til, \"feature branches\", men setter vanligvis høye krav til modenhet og disiplin i utviklingsteamet.","id":18403,"levelFactor":0.45728351482800678,"levelId":207,"name":"Feature toggling","number":15,"sectorFactor":0.77393536845401989,"sectorId":312,"shape":"Circle","size":0},{"description":"\"Feature branches\" innebærer at ny funksjonalitet utvikles i separate kildekodegrener. Det krever fortløpende synkronisering med kodestammen, men selv da er det risiko for sammenflettingsproblematikk (\"merge\"-problemer) når en gren skal inn i kodestammen. Ideelt bør kodegrener stabiliseres kontinuerlig, slik at de kan flettes inn en gang om dagen eller hyppigere. Med stabilisert kode er det ikke farlig å prodsette uferdig funksjonalitet. Feature toggles og hyppige produksjonssettinger gjør hyppig sammenfletting enklere. Versjonskontrollsystemet som brukes, må ha effektiv håndtering av mange grener for at \"feature branches\" skal være gjennomførbart, og på dette området utmerker distribuerte versjonskontrollsystemer, som Git, seg som svært velegnede.","id":18404,"levelFactor":0.45237039662328615,"levelId":207,"name":"Feature branches","number":16,"sectorFactor":0.20483276469913345,"sectorId":312,"shape":"Circle","size":0},{"description":"Kodekvalitetsmetrikker måles ved at automatiske verktøy analyserer kodebasen og rapporterer verdier som antall linjer kode, testdekning, ubrukte metoder eller komplisert logikk. Selv om disse verdiene kun er indikatorer på kodebasens kvalitet, er det ifølge vår erfaring en god korrelasjon. Vi bruker slike metrikker for å flagge smertepunkter i porteføljer med gammel kode, og for å opprettholde kvalitetsfokus i ny kode. Verktøy som Sonar, PMD, Checkstyle og Findbugs har blitt brukt med gode resultater. Metrikkene er dog ingen sovepute, og problemer med arkitekturen eller funksjonelle feil fanges typisk ikke opp.","id":18405,"levelFactor":0.49879684956614068,"levelId":207,"name":"Kodekvalitetsmetrikker","number":17,"sectorFactor":0.57764988588870525,"sectorId":312,"shape":"Circle","size":0},{"description":"Ytelsestester er som oftest tidkrevende å kjøre og kan være tidkrevende å lage. Realistisk testing vil som regel kreve at hele systemet, med alle sine integrasjonspunkter, er satt opp i et noenlunde produksjonslikt miljø. Det er derfor viktig å prøve å bruke verktøy som kan effektivisere kjøring og måling, og man må også ha mulighet for å kunne sammenligne resultater over tid. Derfor bør slik testing automatiseres - og også introduseres tidlig i et prosjektløp - selv om arkitektur og funksjonalitet er under endring. Slik får man muligheter til å måle effekter av endringer (for eksempel innen ytelse og skalerbarhet) og tidlig kunne agere på utilsiktede konsekvenser av endringer. Når det gjelder konkrete verktøy for ytelsestesting, så har vi god erfaring med Gatling, et lasttest-rammeverk hvor man skriver test-scripts ved hjelp av en Scala-basert DSL. Gatling er enkelt å ta i bruk, har rik funksjonalitet og gir gode og utførlige rapporter.","id":18445,"levelFactor":0.42283859068843527,"levelId":207,"name":"Automatisert ytelsestesting","number":18,"sectorFactor":0.90146374629769321,"sectorId":312,"shape":"Circle","size":0},{"description":"For å effektivisere utviklingsarbeidet benytter de fleste prosjekter en mengde \"åpen kildekode\"-komponenter. Dette kan være biblioteker lastet ned via Maven, NuGet, RubyGems eller tilsvarende. Over tid vil det bli oppdaget sårbarheter i noen av disse komponentene, og da er det viktig å være oppmerksom på dette. Etter som mengden biblioteker gjør det vanskelig å holde oversikt over versjoner og sårbarheter manuelt, er automatisering av deteksjon et viktig virkemiddel. Eksempelvis kan automatisering sørge for at bygget bryter dersom det oppdages at komponenter med kjente sårbarheter er i bruk.","id":18446,"levelFactor":0.3863032261147768,"levelId":207,"name":"Automatisert deteksjon av sårbare biblioteker","number":19,"sectorFactor":0.33049868107713576,"sectorId":312,"shape":"Circle","size":0},{"description":"De siste årene har Git blitt et klart førstevalg om man som utvikler kan velge kildekodesystem fritt. Den distribuerte modellen lar en utvikler jobbe effektivt på lokal maskin uten avhengighet av nettverk eller en sentral server, og en slipper kompliserende backup-løsninger. Enkel og robust \"branch\"- og \"merge\"-funksjonalitet åpner for mer eksprimentering og uavhengig implementering av funksjonalitet - en forutsetning for \"feature branches\". Git lar deg lett bytte mellom og dele kodegrener, og lar deg enkelt hoppe til en kritisk feilretting i produksjonskoden, før du ufortrødent kan fortsette med nyutvikling. GitHub, enten brukt som en SaaS-løsning, eller som en intern løsning, kan anbefales som kildekodelager og samhandlingsplattform for utviklingsprosjekter. Vi har gode erfaringer med å bruke tilleggsfunksjonalitet på GitHub, så som Wiki, Issues eller Readme.md-filer. Vi har også brukt funksjonen \"GitHub Pages\" for å publisere enkle statiske sider.","id":18447,"levelFactor":0.43444070803942336,"levelId":208,"name":"Distribuert VCS","number":20,"sectorFactor":0.20823711605769687,"sectorId":312,"shape":"Circle","size":0},{"description":"Sentraliserte kildekodesystemer, som Subversion og TFS, er fortsatt vanlige og vil være utbredt en stund til framover. De er velprøvde og stabile, og er også funksjonelt rike. Imidlertid kommer de ofte til kort dersom man bruker kodegrener og kodesammenfletting i et visst omfang - noe som vil være naturlig om man ønsker å gjøre kontinuerlige leveranser. Distribuerte kildekodesystemer (for eksempel Git) er derimot sterke på dette området.","id":18448,"levelFactor":0.34575438041744988,"levelId":207,"name":"Sentralisert VCS","number":21,"sectorFactor":0.50913745533331312,"sectorId":312,"shape":"Circle","size":0},{"description":"Tidligere ble web-grensesnitt genererert på server-siden, med små JS-snutter som beriket opplevelsen. Nå foretrekker vi rene JavaScript-klienter som snakker med en tilstandsløse REST-tjenester. Web-serveren leverer en enkel oppstartsside med linker til javascript-rammerverk, og deretter tar JS-motoren i nettleseren over og genererer brukeropplevelsen med data fra tjenestene. REST-tjenestene kan brukes av andre klienter, som \"native\" mobil-klienter. Gjort riktig, blir brukeropplevelsen vesentlig bedre enn med server-generert HTML. Vår erfaring er at utviklingshastigheten går opp, men det krever at man har ressurser med \"frontend\"-kompetanse. Selv om det er ønskelig med polyglot-utviklere som behersker både \"frontend\" og \"backend\", så ser vi  i praksis en polarisering i kompetansen.","id":18449,"levelFactor":0.57724124949699329,"levelId":208,"name":"JavaScript-klienter","number":22,"sectorFactor":0.41830689600119608,"sectorId":313,"shape":"Circle","size":0},{"description":"\"Event-sourcing\" innebærer at alle hendelser i applikasjonen lagres og kan hentes ut i den rekkefølgen de oppstod. Nåtilstanden og enhver tidligere tilstand i applikasjonen kan gjenopprettes ved å spille av alle hendelsene siden dag én. En interessant undergruppe av denne modellen er integrasjon ved hjelp av RSS-\/ATOM-feeder, der en applikasjon fortløpende publiserer hendelsene i en paginert feed, som en eller flere klienter kan konsumere for å oppdatere sin egen tilstand. I BEKK har vi sett at denne modellen åpner for en svært robust integrasjonsplattform, og er spesielt aktuelt der nær-sanntidsoppdateringer ikke er nødvendig. Et ekstra pluss er muligheten til å utnytte standard HTTP-caching-mekanismer for å øke ytelsen i integrasjonen.","id":18450,"levelFactor":0.24881017423124849,"levelId":207,"name":"Event sourcing","number":23,"sectorFactor":0.37662407292626554,"sectorId":313,"shape":"Circle","size":0},{"description":"Mini-vertikaler er en arkitekturmodell der en logisk applikasjon deles opp i flere uavhengige applikasjoner som kun deler visuell profil. Et eksempel er en handlekurv-løsning, der én applikasjon håndterer autentisering og handlekurv, en annen håndterer produktsøk og -visning, en tredje tar seg av utsjekksprosessen, mens en fjerde sørger for betaling. Forskjellen fra mikrotjenester med en JS-klient på toppen, er at mini-vertikaler håndterer hele stacken fra GUI og ned. Det er flere grunner til å velge en slik arkitektur. Den først er robusthet, fordi deler av den logiske applikasjonen kan være nede, f.eks på grunn av oppgradering, uten at andre deler av løsningen er påvirket. Det gjør det også mulig å ha ulikt utrullingsregime og -hyppighet for løsningsdelene.  Den andre grunnen er organisatorisk, siden autonome team kan få ansvar for sin del uten å gå i beina på hverandre. Den tredje er teknologisk, siden ulike vertikaler kan bruke svært forskjellige teknologier. I eksemplet over får man skilt ut bruk av sikkerhetsrammeverk, søkemotorer og betalingsløsninger i separate applikasjoner. Arkitekturmønsteret åpner i prinsippet for at helt forskjellige plattformer benyttes, f.eks kan én applikasjon kjøre på Windows\/CLR, mens en annen kjører på Linux\/JVM.","id":23364,"levelFactor":0.58477064498168174,"levelId":207,"name":"Mini-vertikaler","number":24,"sectorFactor":0.68326069368897369,"sectorId":313,"shape":"Circle","size":0},{"description":"Hendelsesdrevet (\"event driven\") arkitektur er en annerledes måte å tenke arkitektur på. Der en før jobbet direkte på data-modellen, jobber en nå med endringer. En hendelse beskriver hvilken ending som skal skje, og endingen utføres så asynkront mot bakenforliggende modell. Fordelen med hendelsesdrevet arkitektur, er at en tenker asynkront fremfor synkront, som er et godt grunnlag for senere parallellisering. Ulempen kan være at en får en litt mer uoversiktlig arkitektur der det kan være vanskelig å følge flyten.","id":23365,"levelFactor":0.4425970426686554,"levelId":207,"name":"Hendelsesdrevet arkitektur","number":25,"sectorFactor":0.15923414833650071,"sectorId":313,"shape":"Circle","size":0},{"description":"3-lags-arkitekturen, med et presentasjonslag, forretningslag og et lag for lagring av data, lever i beste velgående. Det som er nytt, er at man gjerne benytter flere datalagringsplattformer (\"polyglot persistence\"), samtidig som presentasjon flyttes bort fra web-serveren og til JS-klienter og proprietære (\"native\") mobilklienter. Forretningslaget realiseres i større grad av flere små, samarbeidene tjenester (mikrotjenester), ofte utviklet med flere enn ett språk (\"polyglot programming\") .","id":23366,"levelFactor":0.16225291558583491,"levelId":208,"name":"3-lags-arkitektur","number":26,"sectorFactor":0.79286897895889641,"sectorId":313,"shape":"Circle","size":0},{"description":"Det er for tiden mye snakk om å lage tjenester som kan rulles ut automatisk og ofte. For å få til det, kan det ofte være lønnsomt å få ned kompleksiteten. Mikrotjenester kan være med på å løse dette. Det innebærer små, uavhengige tjenester som løser et begrenset problem, helst på under tusen linjer kode. Tjenester kan ha et grensesnitt, eller leve helt for seg selv.  Flere mikrotjenester kan settes sammen for å danne løsninger via aggregerings-mekanismer. Det arketypiske eksempelet er kommandolinjeverktøyene i linux\/unix, som grep, sed og awk, men tankesettet kan brukes i mange sammenhenger. En viktig - men ikke triviell - forutsetning er at du har kontroll på versjons- og utrullingsregimet ditt, slik at tjenestene spiller sammen til enhver tid.","id":23367,"levelFactor":0.34150994677073665,"levelId":207,"name":"Mikrotjenester","number":27,"sectorFactor":0.81692354007013368,"sectorId":313,"shape":"Circle","size":0},{"description":"En del rammeverk krever tett kobling til koden, hvor Hollywood-prinsippet gjelder (\"Don't call us, we'll call you\"). Hvis denne typen rammeverk ikke kan unngås, så bør anti-korrupsjonslag innføres for å holde foretningslogikken ren. Guice er et DI-rammeverk på fremmarsj, og som er enklere å bruke og mindre invaderende enn Spring.","id":23368,"levelFactor":0.6319216011672687,"levelId":207,"name":"Ikke-invaderende rammeverk","number":28,"sectorFactor":0.53494397182997788,"sectorId":313,"shape":"Circle","size":0},{"description":"Asynkrone tjenester er tjenester hvor en sender inn en forespørsel for å få svar på et senere tidspunkt. I en verden hvor en web-side vil medføre flere og flere web-kall, er asynkronitet viktig for å holde ytelsen oppe. Ved å bruke slike kall, holder en tiden på hvert kall til et minimum. Asynkrone tjenester passer også veldig bra til skytjenester. \"Promise\"-basert programmering er et alternativ til \"callback\"- og hendelsebasert håndtering av asynkron kode. Fordelen er mer lesbar kode.","id":23369,"levelFactor":0.2050666117910942,"levelId":207,"name":"Asynkrone tjenester","number":29,"sectorFactor":0.24073287470322463,"sectorId":313,"shape":"Circle","size":0},{"description":"Actors er en gammel programmerings-modell som har fått en ny vår i de siste årene igjennom rammeverk som Akka. Actors er en modell som løser problemer rundt skalering over flere cpu'er og maskiner. En fjerner problemer rundt låsing og synkronisering ved å dele opp oppgaver ned til enheter med arbeid. Akka kan brukes fra både Scala og Java og har fokus på ytelse og feiltoleranse. Rammeverket har mye nyttig funksjonalitet og vurderes innført i flere prosjekter.","id":23370,"levelFactor":0.69747301628722735,"levelId":207,"name":"Actors","number":30,"sectorFactor":0.36157503955550135,"sectorId":313,"shape":"Circle","size":0},{"description":"Protokollen fungerer forsåvidt, men er tung og understøtter ikke løst bundet og skalerbar arkitektur på samme måte som godt designede REST-tjenester. Fortsatt blir det trøbbel med kryss-plattform-integrasjon, og WS-* blir ofte for mye av det gode, med tunge utrullingsregimer og krevende feilsøking.","id":23371,"levelFactor":0.51229548231081823,"levelId":206,"name":"SOAP\/WS-*","number":31,"sectorFactor":0.53796209101968173,"sectorId":313,"shape":"Circle","size":0},{"description":"REST er like mye applikasjonsdesign som selve protokollen. Brukt riktig, kan REST-tankegang hjelpe til å gi gode tjenester, desentralisert infrastruktur, effektiv ressursbruk, lav kompleksitet og god skalering. Det passer som hånd i hanske med arkitektur som er basert på mindre, løst koblede komponenter (typisk sky-arkitektur), og samtidig for løsninger som har ulike konsumenter\/frontend-løsninger. REST på nivå 1 innebærer å bruke URL-adresserbare ressurser over HTTP, og nivå 2 HTTP-verb for å gjøre operasjoner på ressursene. Denne formen for REST er den vi ser desidert mest av på prosjekter, selv om puristene vil si at det ikke er REST i det hele tatt.","id":23372,"levelFactor":0.41480818108699513,"levelId":208,"name":"REST nivå 1-2","number":32,"sectorFactor":0.12566591637800231,"sectorId":313,"shape":"Circle","size":0},{"description":"Sann REST, som betyr hypermediakontroll. I tillegg til adresserbare ressurser og bruk av HTTP-verb, så returnerer tjenestene svar som også indikerer hvordan klienten kan komme videre. Typisk legges det linker til ressurser, med relasjoner som forteller hvordan ressursene kan manipuleres. Fordelen er at klienten ikke trenger å snekre sammen nye URL'er basert på en implisitt protokoll, samtidig som server-siden står fritt til å endre adresseringen av ressurser. I BEKK gjør vi prosjekter også på dette nivået, men fortsatt er det nybråttsarbeid.","id":23373,"levelFactor":0.616952523840168,"levelId":207,"name":"REST nivå 3","number":33,"sectorFactor":0.89163972287051374,"sectorId":313,"shape":"Circle","size":0},{"description":"En lettvekts applikasjonsserver forenkler infrastruktur og konfigurasjonen betraktelig og gjør det lett å skreddersy applikasjonen basert på de kravene som er nødvendige. Den gjør det også mye enklere å gjennomføre testing. Drift og forvaltning blir kraftig forenklet fordi hele applikasjonen kjører som én prosess som er enkel å starte, stoppe og monitorere. Implementering av nedetidsfri produksjonssetting og konfigurasjon i kode blir også lettere.  Serverne er som regel lite ressurskrevende og kan kjøre på utviklernes eller forretning sine maskiner. I BEKK har vi god erfaring med Jetty fra flere prosjekter.","id":23374,"levelFactor":0.41817836222474419,"levelId":208,"name":"Lettvekts applikasjonsservere","number":34,"sectorFactor":0.71887357082867,"sectorId":313,"shape":"Circle","size":0},{"description":"De kommersielle applikasjonsserverne har som oftest lukket kildekode, som begrenser muligheten til å modifisere og utvide dem, samtidig som det blir vanskeligere å skjønne hvordan de virker. Skripting og automatisering blir vrient, og det er vanskelig å velge hvilke rammeverk man ønsker å bruke. Kontinuerlig leveranse blir dermed tyngre, og derfor vi velger lettvektsvariantene så snart vi har anledning. ","id":23375,"levelFactor":0.10641175350897882,"levelId":208,"name":"Java EE 5\/6 applikasjonsservere","number":35,"sectorFactor":0.47108264219444662,"sectorId":313,"shape":"Circle","size":0},{"description":"En ESB er en arkitekturmodell som orkestrerer kommunikasjon mellom tjenester i en tjenesteorientert arkitektur (SOA). En ESB sørger for transformasjon og ruting av meldinger mellom tjenester, og kommersielle produkter tilbyr gjerne et bredt spekter av funksjonalitet, som monitorering, sikkerhet, last-balansering, versjonering, kø- og feilhåndtering. Imidlertid ser vi ofte at ESB-produktene blir unødvendig komplekse og i liten grad gir den verdiøkningen som er forespeilet. Ofte er også teamet som forvalter bussen for lite, og blir en flaskehals i utviklingsarbeidet. I den grad en \"tjenestebuss\" i det hele tatt trengs, så bør lettvektsalternativene vurderes først.","id":23376,"levelFactor":0.19992235944682368,"levelId":207,"name":"Enterprise Service Bus","number":36,"sectorFactor":0.15819200517512322,"sectorId":313,"shape":"Circle","size":0},{"description":"I .NET-verdenen er NServicebus etter vår oppfatning SOA som det burde være. Fortsatt assosierer nok de fleste \"SOA\" med SOAP og kommunikasjon frem og tilbake. NServicebus er byggt på enveis meldingsutveksling og benytter seg av køsystem for en effektiv kommunikasjon som også er transaksjonell. For en effektiv SOA-strategi trenger man asynkrone tjenester som kan gjøre sin del klar og senere kommunisere svaret videre eller flagge at tjenesten er klar. Med rammeverk som NServicebus blir dette et enklere problem. Apache Camel for JVM'en har åpen kildekode og tilbyr de fleste mønstrene du finner i \"Enterprise Integration Patterns\"-boka. Vi liker at det drar med seg få avhengigheter, og at det er mulig å skrive testbar kode mot det.","id":23377,"levelFactor":0.28889270429993213,"levelId":207,"name":"Lettvekts Service Bus","number":37,"sectorFactor":0.054673511515155405,"sectorId":313,"shape":"Circle","size":0},{"description":"Mange bedrifter har investert betydelige ressurser i en egen, intern serverpark, både i form av infrastruktur og en driftsorganisasjon. Selv om det er blitt vanlig å overlate forvaltningen til profesjonelle infrastruktur-leverandører og virtualisering gjennomgående blir brukt, så er erfaringen at det gjerne er en tidkrevende øvelse å gjennomføre vesentlige endringer i infrastrukturen. Fremveksten av gode og rimelige PaaS- og IaaS-løsninger, både eksterne og interne, gjør deler av denne jobben enklere, og åpner ikke minst for enklere skalering. Ny infrastruktur bør i større grad være sky-basert.","id":23378,"levelFactor":0.26980399582220438,"levelId":207,"name":"Intern serverpark","number":38,"sectorFactor":0.6245105278600287,"sectorId":313,"shape":"Circle","size":0},{"description":"Automatisering av miljø og utrulling kan spare voldsomt med tid og frustrasjon, og er en forutsetning for hyppigere produksjonssettinger. En fleksibel infrastuktur (i form av IaaS eller PaaS-løsninger) kan være hjelpsomt, men strengt tatt ikke nødvendig. En privat PaaS-løsning vil kunne gi store fordeler ved utrulling og oppsett av applikasjoner, både ved produksjonssetting og under utvikling. Det er lav terskel for eksperimentering med oppsettet, og det kan forenkle utviklingsløp og kontinuerlig utrulling betraktelig.","id":23379,"levelFactor":0.5096161738851458,"levelId":207,"name":"Private PaaS\/IaaS ","number":39,"sectorFactor":0.26813755105089804,"sectorId":313,"shape":"Circle","size":0},{"description":"Mange av de samme fordelene som private PaaS, men uten fordelene det kan være å ha alt internt. F.eks. kan det bli større terskel å bruke en public PaaS til utvikling i stor skala. Public PaaS-løsninger er mer modne enn de private og har vært brukt i stor skala i flere år. Heroku er et eksempel. Offentlige IaaS-løsninger gir store fordeler ved anskaffelse (og avskaffelse), oppsett og automatisering av ny maskinvare. Moden teknologi og flere løsninger, og Azure har blitt godkjent for bruk i det offentlige i Sverige.","id":23380,"levelFactor":0.18540367705787003,"levelId":207,"name":"Public PaaS\/IaaS ","number":40,"sectorFactor":0.91534948347145617,"sectorId":313,"shape":"Circle","size":0},{"description":"Web-baserte mobil- og småflateapper er tilsynelatende det enkle valget når man skal lage innhold for små flater. HTML5 og CSS3 har god støtte hos de markedsledende mobil- og nettbrettleverandørene, men det er selvfølgelig nok varianter til at avansert bruk skaper hodebry. I tillegg mister brukeren den kjente brukeropplevelsen fra enheten, og ytelsen og funksjonsrikheten når aldri opp til \"native\" app'er. \"Responsive Design\" er et nøkkelord for å lage web-innhold som fungerer på mange flater.","id":23381,"levelFactor":0.12597155112492428,"levelId":208,"name":"Web-basert app","number":41,"sectorFactor":0.25776211681831318,"sectorId":313,"shape":"Circle","size":0},{"description":"En hybridapp gir det beste - og verste - fra webapper og \"native\"-app'er. Web-basert innhold får et skall fra plattformen, som gir forbedringsmuligheter når det gjelder brukeropplevelser. For eksempel kan man lage faner i plattformens rammeverk, der hver fane viser tilpasset innhold. Det åpner også for å gjøre appen tilgjengelig i plattformens distribusjonskanal, f.eks Apples AppStore eller Google Play, som i tillegg til å gi mulighet til å ta seg betalt, også gir statistikk om bruk og popularitet. Ulempen er at hybrid-app-skallet må skreddersys hver plattform, og web-innholdet fortsatt har sine vanlige begrensninger.","id":23382,"levelFactor":0.17477639151781665,"levelId":207,"name":"Hybrid-app","number":42,"sectorFactor":0.50282940258080966,"sectorId":313,"shape":"Circle","size":0},{"description":"En \"native\" app gir en full palett av muligheter på plattformen, og ytelse og brukeropplevelse er uovertruffen. Utfordringen er imidlertid ikke bare å støtte flere plattformer som Windows Phone, Android og iOS, men også forskjellige versjoner av de ulike plattformene.","id":23383,"levelFactor":0.1984077858747175,"levelId":208,"name":"Native-app","number":43,"sectorFactor":0.60248802535672608,"sectorId":313,"shape":"Circle","size":0},{"description":"I disse NoSQL-tider er det fristende å tenke at RDBMS-løsninger havner på historiens skraphaug. Det er feil, og relasjonsdatabaser vil være en hjørnesten i de fleste forretningsløsninger i årene fremover. I BEKK har vi god erfaring med et bredt spekter av relasjonsdatabaser, og vi ser at åpne systemer som MySql og PostgresSql holder godt følge med de kommersielle tungvekterne som Microsoft og Oracle. Som alltid er det lurt å unngå de mest proprietære SQL-tilpasningene, og holde forretningslogikken utenfor databasen.","id":23384,"levelFactor":0.62323011343098778,"levelId":208,"name":"Relasjonsdatabaser","number":44,"sectorFactor":0.73375012250468685,"sectorId":313,"shape":"Circle","size":0},{"description":"Det er et bredt utvalg av \"key-value\"-databaser, som stort sett har det til felles at de tilbyr rask lagring og\/eller uthenting av oppføringer basert på nøkler, og støtter gjerne effektivt store volumer og enkel opp- og nedskalering etter behov. En fordel er at det gjerne stilles få krav til skjema\/struktur, som gir mye fleksibilitet og bevegelsesfrihet. Redis er et meget rask minnebasert \"key\/value\"-lager med store mengder funksjonalitet, og passer godt til å \"lime\" sammen diverse aspekter ved webapplikasjoner. Det greit å huske at søkemotorer kan betrakes som en \"key-value\"-databaser, og for eksempel Solr er lett å ta i bruk og kan anvendes som et robust lager med høy ytelse og et rikt API. Den er ofte svært enkel å introdusere i eksisterende løsninger ettersom den er Java-basert og kan kjøre i vanlige web-containere\/app-servere.","id":23385,"levelFactor":0.33431789582457422,"levelId":207,"name":"Key-value-databaser","number":45,"sectorFactor":0.7259178752440667,"sectorId":313,"shape":"Circle","size":0},{"description":"ElasticSearch er en Java-basert server som kan brukes som \"key-value\"-database, søkemotor eller for å dekke enklere \"Business Intelligence\"-behov. Den har avansert funksjonalitet for clustering, sharding, redundant lagring og kan dekke de fleste sanntidskrav. Samtidig er produktet lett å sette opp i basiskonfigurasjon og har et avansert REST-basert API. ElasticSearch er for tiden i 0.9 og har mindre fartstid enn Lucene-slektningen Solr. Solr har innebygget funksjonalitet som dekker svært mange av de vanlige kravene forbundet med fritekstsøk - spesielt språkstøtte og fasettering. Solr takler store datamengder, har svært god ytelse, tilbyr ulike klient-APIer og dataformater, og er lett å ta i bruk.","id":23386,"levelFactor":0.42481893536774235,"levelId":208,"name":"Åpne søkemotorer","number":46,"sectorFactor":0.47754038955159994,"sectorId":313,"shape":"Circle","size":0},{"description":"Neo4J er den mest populære grafdatabasen på markedet i dag. Grafdatabaser lagrer dataene i strukturerte grafer i stedet for tabeller, og passer særdeles godt til assosiative datamengder. Neo4J skalerer meget godt, og slår selvfølgelig RDBMS-systemer ned i støvlene i nettverksspørringer.","id":23387,"levelFactor":0.57197382086456772,"levelId":207,"name":"Grafdatabaser","number":47,"sectorFactor":0.072034152143302652,"sectorId":313,"shape":"Circle","size":0},{"description":"En del av dagens applikasjoner har lagringsbehov som passer dårlig med relasjonsmodellen. Samtidig er det fornuftig å bruke verktøy som er godt tilpasset behovene man har. RavenDB er en dokumentdatase implementert i .NET og tilbyr mye god funksjonalitet. Det finnes en god .NET-klient, eller man kan benytte seg av et HTTP-basert API. MongoDB er en meget allsidig database som passer spesielt godt til å utveksle JSON mot tykke JavaScript-applikasjoner. Det er begrenset støtte for relasjoner og transaksjoner på tvers av dokumenter, og det bør det blit tatt hensyn til under utvikling.","id":23388,"levelFactor":0.90721414001421463,"levelId":207,"name":"Dokumentdatabaser","number":48,"sectorFactor":0.74601375689038152,"sectorId":313,"shape":"Circle","size":0},{"description":"ORM-rammeverk er svært utbredt. I Java-verdenen dominerer Hibernate, men andre JPA-implementasjoner er utbredt. I en del av våre prosjekter erstattes JPA med for eksempel Spring JDBC, som er mer lettvekts og gir mer kontroll og mulighet for optimaliserte spørringer. LINQ, som kom med .NET 3.5, snudde problemstillingen litt på hodet, og lot utvikleren bruke samme konstruksjoner til å gjøre spørringer mot XML og objektstrukturer, i tillegg til mot databaser.","id":23389,"levelFactor":0.13200972582026482,"levelId":208,"name":"ORM-rammeverk","number":49,"sectorFactor":0.7929490569172627,"sectorId":314,"shape":"Circle","size":0},{"description":"Spring Security er et modent Java-rammeverk for autentisering og autorisering.  For enkle løsninger kan Spring Security bli for komplekst, i disse løsningene anbefaler vi Apache Shiro, som er enklere å komme i gang med. Apache Shiro er et Java-rammeverk som håndterer autentisering, autorisering, sesjonshåndtering og kryptering. Det har god støtte for tilleggsfunksjonalitet en vanligvis ikke finner i slike rammeverk, eksempler på dette er korrekt caching av bruker-objekter og \"husk meg\"-støtte ved innlogging. OWASP AntiSamy gjør det mulig å la brukere publisere HTML uten at det utsetter applikasjonen for XSS-sårbarheter. Det er viktig at Antisamy-policyen er restriktiv, jo mer åpen policyen er, jo større risiko har en for å introdusere hull som gjør at en ondsinnet bruker kan injisere kjørbar kode.","id":23390,"levelFactor":0.856915499502476,"levelId":207,"name":"Sikkerhetsrammeverk","number":50,"sectorFactor":0.16950131892286441,"sectorId":314,"shape":"Circle","size":0},{"description":"Store datamengder og mer distribuerte og autoskalerbare systemer legger til rette for bruk av grid-løsninger både for prosessering av data og caching på tvers av mange instanser. I BEKK har vi erfaring med GemFire og Hazelcast fra prosjekter. Sistenevnte er åpen kildekode, men ikke fullt så modent som GemFire.","id":23391,"levelFactor":0.20930818890357417,"levelId":207,"name":"Grid-rammeverk","number":51,"sectorFactor":0.58059105125250421,"sectorId":314,"shape":"Circle","size":0},{"description":"Mens Java 7 kom med litt syntaktisk sukker, gir Java 8 oss endelig støtte for funksjonell programmering. Dette er sårt etterlenget, snart 10 år etter at C# gav det samme til .NET-verdenen. Det blir spennende å se om det er tilstrekkelig til å dytte Scala ned fra den funksjonelle tronen i JVM-sfæren. I tillegg kommer Java 8 med forbedringer i sikkerhet og parallellisering og en del annen nyttig funksjonalitet.","id":23392,"levelFactor":0.13793103448275862,"levelId":208,"name":"Java 8","number":52,"sectorFactor":0.44499697517453612,"sectorId":314,"shape":"Circle","size":0},{"description":"Scala er en hybrid av et funksjonelt og et objektorientert programmeringsspråk som kjører på JVM-en. Scala har et avansert typesystem og kompilerer direkte til JVM-bytekode. Språket tilbyr både en konsis syntaks, vanligvis forbundet med dynamiske språk, og kjøretidsytelse på høyde med Java eller bedre. Scala har i de siste årene blitt et av de aller mest populære alternative språkene på JVM-en og brukes i store forretningskritiske systemer hos blant annet LinkedIn, Twitter og The Guardian. Det har lav terskel for Java-utviklere og avansert IDE-støtte i både Eclipse og IntelliJ. I Bekk bruker vi Scala sammen med Lift og Akka i kundeprosjekter. Vi ser også på Play! 2 som et alternativ til Ruby on Rails eller andre MVC-baserte webrammeverk. Scala kan tas inn i eksisterende utviklingsmiljø og rulles ut på eksisterende Java-infrastruktur og er et reelt alternativ til Java.","id":23393,"levelFactor":0.63327210834553671,"levelId":207,"name":"Scala","number":53,"sectorFactor":0.34828015713017429,"sectorId":314,"shape":"Circle","size":0},{"description":"Clojure er en LISP-dialektet som kjører på JVM'en. For 5-6 år siden ville det i beste fall vært eksentrisk å vurdere LISP-avarter i forretningskode, men med økende krav til parallellisering og derigjennom et ønske om å skrive funksjonell kode, har LISP blitt langt mer utbredt og akseptert. Likevel tror vi at det store flertall vil nøye seg med Java 8, Scala, C# eller JavaScript til å løse denne typer problemer. Clojure vil forbli for spesielt interesserte.","id":23394,"levelFactor":0.746002528305988,"levelId":206,"name":"Clojure","number":54,"sectorFactor":0.81411529162568785,"sectorId":314,"shape":"Circle","size":0},{"description":"I et tiår har C# ligget minst et hestehode foran Java i uttrykkskraft, og CLR'en er et fullgodt alternativ til JVM'en. Fellesskapet rundt Java er selvfølgelig mye større, og tilgangen til åpne kildekodekomponenter er nok fortsatt en størrelseorden eller to høyere. Samtidig er det enklere å navigere i .NET-universet, og mye er lært av Java sine feil og mangler. I C# klarte man å lage en Generics-implmentasjon som virker, og LINQ er enklere og bedre enn JPA. Med C# 5.0 blir det enda enklere å gjøre asynkron programmering, og det ser bedre enn Java 8.","id":23395,"levelFactor":0.47251522273178093,"levelId":208,"name":"C#","number":55,"sectorFactor":0.5,"sectorId":314,"shape":"circle","size":0},{"description":"Funksjonell programmering er noe som kommer mer og mer. Det gir en muligheter å være mer kompakt i det man skriver og samtidig komme nærmere problemet man løser. F# er bra integrert i .NET så du kan benytte det kun i den delen av applikasjonen der du trenger kraften i et funksjonelt språk.","id":23396,"levelFactor":0.57220162109996375,"levelId":207,"name":"F#","number":56,"sectorFactor":0.69625927937984444,"sectorId":314,"shape":"Circle","size":0},{"description":"SharePoint 2013 tilbyr mye nytt utover det som eksisterte i SharePoint 2010. Eksempelvis har publisering blitt forbedret, brukergrensesnittet har blitt oppdatert til Win8-look, My SIte har nå \"social features\" som f.eks aktivitetsstrøm og integrasjon med Yammer er på plass. Search Server (tidligere FAST) er blitt innebygget, og administratorfunksjonaliteten er betraktelig forbedret. En av de største nyhetene i SharePoint 2013 er den nye app-modellen. Denne omfavner web-standarder slik at utviklere kan lage grensesnitt ved hjelp av HTML og JavaScript, og utnytte SharePoint- og REST-tjenster rett fra klientsiden via JavaScript og JSON. Med app-modellen kan man også lage egne REST-tjenester og en web-hosting-plattform på fritt valgt teknologi for å håndtere kompleks logikk og integrasjon av data og tjenester. Den nye \"cloud app\"-modellen utnytter OAuth for sikker kommunikasjon mellom SharePoint og andre, distribuerte løsninger.","id":23397,"levelFactor":0.35858361249178372,"levelId":208,"name":"SP2013","number":57,"sectorFactor":0.22284549707306023,"sectorId":314,"shape":"Circle","size":0},{"description":"SharePoint 2010 er i dag i bruk av mange, og vil fortsatt være støttet av Microsoft. Men om en vurderer nyutvikling så er SharePoint 2013 absolutt å anbefales. Over tid bør også dagens SP2010-løsninger migreres over til SharePoint 2013.","id":23398,"levelFactor":0.79636232400200413,"levelId":206,"name":"SP2010","number":58,"sectorFactor":0.42677101368723475,"sectorId":314,"shape":"Circle","size":0},{"description":"Skal du lage en ny web-løsning i dag på .NET, så er MVC 4 det selvfølgelige valget. MVC gjør det lett å skille mellom visning og logikk, og er generelt mye mer testbart en sin storebror WebForms. Razor er også en veldig god visningsmotor som gir deg som utvikler full kontroll på HTML'en som blir generert. Det kommer godt med i disse HTML5-tider.","id":23399,"levelFactor":0.33019276886411775,"levelId":208,"name":"ASP.NET MVC","number":59,"sectorFactor":0.89037992285461842,"sectorId":314,"shape":"Circle","size":0},{"description":"ASP.NET Web API er Microsofts implementasjon av et Web API på toppen av HTTP. Rammeverket definerer ikke hvordan du skal lage REST-tjenester, men er kun en lett abstraksjon på toppen av protokollen. Det finns alternativer til Web API, som Nancy og ServiceStack, som man også kan vurdere.","id":23400,"levelFactor":0.15724554694601486,"levelId":208,"name":"ASP.NET Web API","number":60,"sectorFactor":0.10157378026138796,"sectorId":314,"shape":"Circle","size":0},{"description":"ASP.NET WebForms var ment å være en myk landing i overgangen fra ASP til ASP.NET da .NET ble lansert. Nå oppleves en serverbasert modell for generering av side-basert HTML gammeldags og lite effektiv, både for utviklere og brukere.","id":23401,"levelFactor":0.53342619746320374,"levelId":206,"name":"ASP.NET Web forms","number":61,"sectorFactor":0.58359800487376245,"sectorId":314,"shape":"Circle","size":0},{"description":"SignalR er lite rammeverk som forenkler utvikling av web-applikasjoner som krever sanntidsutveksling av data. WebSocket brukes når det er tilgjengelig, ellers benyttes andre teknologier transparent for klienten. Vi ser ikke veldig mye bruk av dette på prosjekter foreløpig.","id":23402,"levelFactor":0.59834231366934187,"levelId":207,"name":"ASP.NET SignalR","number":62,"sectorFactor":0.91721945479270939,"sectorId":314,"shape":"Circle","size":0},{"description":"Ruby-on-rails demonstrerte hvordan Ruby kunne utnyttes til å bygge en DSL der konvensjon trumfer konfigurasjon. Rails lar en utvikler levere en enkel CRUD-applikasjon for web med svært kompakt kode på minutter, og ytelsesmessig er det OK. Det er grunnen til at det er en favoritt i oppstartsmiljøer, men vi ser liten adopsjon i etablerte bedrifter. Fortsatt er det forholdsvis langt mellom de gode Rails-utviklerne, og vi har vært nødt til å reimplementere Rails-applikasjoner på mer tradisjonelle plattformer av forvaltningshensyn.","id":23403,"levelFactor":0.0715233091147405,"levelId":208,"name":"Ruby-on-rails","number":63,"sectorFactor":0.61657196680368409,"sectorId":314,"shape":"Circle","size":0},{"description":"Sinatra er et lettvekts web-rammeverk i Ruby. Det følger ikke en MVC-tankegang, som Rails, men fokuserer på kortest mulig vei til å levere web-innhold. Det er et godt rammeverk for prototyping, men ikke noe vi venter å se mye av på produksjonsserveren.","id":23404,"levelFactor":0.3455368492938255,"levelId":207,"name":"Sinatra","number":64,"sectorFactor":0.24503707268424235,"sectorId":314,"shape":"Circle","size":0},{"description":"Django er et python-basert web-rammeverk som lover å levere Web-applikasjoner raskere med mindre kode. Et greit alternativ for python-entusiastene, men vil nok ikke bli \"mainstream\"","id":23405,"levelFactor":0.20178218369112172,"levelId":207,"name":"Django","number":65,"sectorFactor":0.93513962575665677,"sectorId":314,"shape":"Circle","size":0},{"description":"Apache Wicket er et komponentorientert web-rammeverk i Java. Det har vært ganske så populært de siste 4-5 årene, og vi har gjort vår andel av web-prosjekter med Wicket. Nå er den komponentorienterte web-æraen på hell, og vi ville ikke startet en ny web-applikasjon på Wicket.","id":23406,"levelFactor":0.045439202221254346,"levelId":208,"name":"Wicket","number":66,"sectorFactor":0.269487996936851,"sectorId":314,"shape":"Circle","size":0},{"description":"Spring var tidlig ute med å tilby et MVC-rammeverk for Java. Som for de fleste spring-rammeverkene så oppleves det litt \"oppblåst\", og det blir gjerne en del standardkode for å knytte sakene sammen. Det er likevel et rammeverk som er svært stabilt og får jobben gjort, og vi har brukt det i flere prosjekter. Dokumentasjonen holder høy kvalitet, og det er ikke vanskelig å finne utviklere med kompetanse på plattformen. Vår oppfatning er at over tid vil Spring MVC erstattes av Jersey og JavaScript-klienter, men det skjer ikke over natten.","id":23407,"levelFactor":0.24438242834342283,"levelId":208,"name":"Spring MVC","number":67,"sectorFactor":0.60428353622270092,"sectorId":314,"shape":"Circle","size":0},{"description":"Grails er et åpent, Groovy-basert web-rammeverk, og at JVM'en er kjøretidsmiljøet, kan gjøre det lettere å vinne innpass i Java-miljøer. Grunnprinsippet er MVC, og løftet er strømlinjeformet utvikling der konvensjoner trumfer konfigurasjon. Vi bygger kompetanse og gjør litt prototyping på det, men vi har vel ikke stor tro på at det vinner innpass hos store, etablerte aktører. Oppstartsbedrifter som fritt kan velge plattform, kan være tjent med å ta en titt på Grails, men vi tror vel ikke Groovy kommer til å få stor utbredelse.","id":23408,"levelFactor":0.29213961275562239,"levelId":207,"name":"Grails","number":68,"sectorFactor":0.4374368582484971,"sectorId":314,"shape":"Circle","size":0},{"description":"Node.js er en spennende tanke, og bra implementert på Chrome sin V8-motor. Etter hvert som JS-kompetanse er et must på front-end-siden, er det besnærende tanke å kunne bruke JS gjennom hele stacken ned til et JSON\/REST-basert datalager. Som et hendelse-orientert, ikke-blokkerende web-rammeverk er det velegnet til å håndtere data-intensive sanntidssystemer på web.  Enside-applikasjoner og node.js passer som hånd i hanske. Vi har tro på node.js, men det er nok et lite stykke igjen til bred adopsjon.","id":23409,"levelFactor":0.3140895024679225,"levelId":207,"name":"Node.js","number":69,"sectorFactor":0.79248109186455429,"sectorId":314,"shape":"Circle","size":0},{"description":"GWT kan ikke helt sidestilles med andre web-rammeverk. Koden skrives i Java og kompileres til JavaScript og HTML som kjøres i nettleseren. For debugging kan koden også kjøres på en JVM. Til forskjell fra andre web-rammeverk, så legges det få føringer på hvordan applikasjonen skal skrus sammen ende-til-ende. Google gjør mye riktig og får i kraft av sin posisjon mye oppmerksomhet, men vi er litt skeptiske til ideen om å skrive i java og kompilere til javascript. Det er kanskje like greit å lære seg javascript først som sist, særlig når adopsjonen er ganske laber.","id":23410,"levelFactor":0.43757254893376979,"levelId":206,"name":"Google Web Toolkit","number":70,"sectorFactor":0.28335198377025672,"sectorId":314,"shape":"Circle","size":0},{"description":"JSF erstattet ren JSP som Javas web-utviklingsplattform. JSF 2.0 har fått med seg en viss Ajax-støtte, men den komponent-orienterte tilnærmingen er i dag utdatert. Erfaringen er at utviklingskostnaden blir høyere og brukeropplevelsen dårligere med JSF enn med enside-applikasjoner med en REST-backend, gitt man har kompetansen til å levere det. Selvfølgelig, i en J2EE-butikk er JSF kokebokmåten å løse web-opplevelsen på, men vi ville ikke ha brukt det på nye applikasjoner.","id":23411,"levelFactor":0.84613624486099781,"levelId":206,"name":"JavaServer Faces ","number":71,"sectorFactor":0.72094627904283815,"sectorId":314,"shape":"Circle","size":0},{"description":"Apache Tapestry er et litt mer lettvekts web-rammeverk enn JSF, men deler den komponent-orienterte tilnærmingen. Det har ikke fått voldsom utbredelse, og vi ser det ikke så ofte. Det er nok ikke helt fremtiden.","id":23412,"levelFactor":0.79956395556600268,"levelId":206,"name":"Tapestry","number":72,"sectorFactor":0.14385010572929935,"sectorId":314,"shape":"Circle","size":0},{"description":"JSP var java-verdenens svar på Microsofts ASP-popularitet. Dynamiske sider blir generert ved å drysse java-snutter innimellom HTML-tagger, og grei ytelse oppnås ved at sidene kompileres ned til servlets. JSP-baserte applikasjoner finnes i rikt monn ennå og må forvaltes, men ingen starter nyutvikling på JSP i dag.","id":23413,"levelFactor":0.071885515444189127,"levelId":206,"name":"JSP","number":73,"sectorFactor":0.4477924386966729,"sectorId":314,"shape":"Circle","size":0},{"description":"WebSocket er en standardisert løsning på problemet med å opprette toveis kommunikasjon mellom nettleser og server. Nettrafikken blir kraftig redusert ved små forespørsler\/svar sammenliknet med ajax-kall fordi man slipper http-metadata. WebSocket-API'et har fått bra støtte i nettlesere, men det er fornuftig å å bruke rammeverk som kan falle tilbake til andre kommunikasjonsmetoder, som \"lang polling\", når nettleseren ikke har tilstrekkelig støtte. socket.io er et eksempel på et slikt bibliotek. Det finnes server-side rammeverk for WebSocket-kommunikasjon for de fleste språk og plattformer nå.","id":23414,"levelFactor":0.321926145632536,"levelId":207,"name":"WebSockets","number":74,"sectorFactor":0.34477264566621235,"sectorId":315,"shape":"Circle","size":0},{"description":"SASS er en preprosessor til CSS som gir variabler, \"mixins\" og  funksjoner. Det kompilerer ned til ren CSS med en JavaScript-kompilator. Preprosessereren er skrevet i Ruby, som kan være marginalt vanskeligere å innføre enn lillebroren LESS, som er skrevet i JavaScript. SASS er generelt ansett for å være litt kraftigere enn LESS – som kan være \"a blessing and a curse\" - det er litt for lett å lage for komplekse ting. Vi anbefaler å bruke SASS\/LESS i prosjekter som starter opp nå.","id":23415,"levelFactor":0.49883516275452522,"levelId":208,"name":"SASS, LESS","number":75,"sectorFactor":0.465621577123143,"sectorId":315,"shape":"Circle","size":0},{"description":"TypeScript og CoffeeScript er to eksempler på at JavaScript i stadig større grad må betraktes som en plattform á la JVM og CLR. Forslagene til Ecmascript 6 går også i denne retningen, med mer støtte for kompilatorer og høynivåkonstruksjoner. Både TypeScript og CoffeeScript kompilerer ned til JavaScript, men mens TypeScript holder seg veldig nær JS-syntaksen, så er CoffeeScript et nærmere et eget programmeringsspråk, som forenkler en del vanlige konstruksjoner. Vi holder øye med disse språkene og bygger kompetanse på dem, men forventer ikke bred adopsjon.","id":23416,"levelFactor":0.28116856638515542,"levelId":207,"name":"TypeScript, CoffeeScript","number":76,"sectorFactor":0.69547138402423947,"sectorId":315,"shape":"Circle","size":0},{"description":"Webapplikasjoner blir stadig større og mer komplekse på klientsiden. Dette medfører at behovene for å modularisere og strukturere JavaScript-kode øker. RequireJS er en implementasjon av AMD-standarden for definering av moduler og hvordan avhengigheter mellom moduler skal spesifiseres og løses. Vi bruker det veldig ofte i nye énside-applikasjoner.","id":23417,"levelFactor":0.7091284854182851,"levelId":208,"name":"RequireJS","number":77,"sectorFactor":0.30452861597575992,"sectorId":315,"shape":"Circle","size":0},{"description":"KnockoutJS er et lettvekts JavaScript-rammeverk for \"templating\" og databinding.  Rammeverket er sterkt inspirert av MVVM-tankegangen brukt i Silverlight.","id":23418,"levelFactor":0.624130414158107,"levelId":207,"name":"KnockoutJS","number":78,"sectorFactor":0.50347876194467389,"sectorId":315,"shape":"Circle","size":0},{"description":"Ext.js er et rent javascript-rammeverk for å bygge rike web-applikasjoner, inkludert mange datavisualiseringskomponenter. Det er nå lisensbelagt, og ikke vårt førstevalg.","id":23419,"levelFactor":0.68173757589758333,"levelId":206,"name":"Ext.js","number":79,"sectorFactor":0.51228843058098317,"sectorId":315,"shape":"Circle","size":0},{"description":"jQuery for basisoperasjoner som dom-manipulasjon og ajax-kall, er et must. Det rydder opp i det meste av problemer knyttet til forskjellige JavaScript-implementasjoner i nettlesere, men ukritisk bruk kan gi en lite vedlikeholdbar kodebase. Vi bruker det gjerne sammen med AMD-rammeverk for bedre struktur.","id":23420,"levelFactor":0.52181017566790588,"levelId":208,"name":"jQuery","number":80,"sectorFactor":0.81933105879653367,"sectorId":315,"shape":"Circle","size":0},{"description":"Underscore er en JS-verktøykasse med bred støtte for konstruksjoner kjent fra funksjonell programmering, som foreach, map, reduce, filter osv. Vi bruker det sammen med andre rammeverk i web-applikasjoner, men det er selvfølgelig også velegnet på server-siden, f.eks i node.js. I moderne er JavaScript-utvikling er Underscore nærmest å betrakte som et \"must\"","id":23421,"levelFactor":0.14576503850989875,"levelId":208,"name":"Underscore","number":81,"sectorFactor":0.24091435125827709,"sectorId":315,"shape":"Circle","size":0},{"description":"Backbone.js er brukt med suksess i mange BEKK-prosjekter. Rammeverket har stor adopsjon og kommer til å være med i mange år fremover. Det gir struktur i JS-tunge web-applikasjoner gjennom enklere modell-, \"view\"- og hendelsehåndtering.","id":23422,"levelFactor":0.37344358251065529,"levelId":208,"name":"Backbone","number":82,"sectorFactor":0.65262520339580632,"sectorId":315,"shape":"Circle","size":0},{"description":"Angular.js er et Google-støttet JavaScript-rammeverk. Det er til en viss grad inspirert av Java-verdenen og benytter seg av IoC-mekanismer, som gir gode muligheter for å få på plass automatiske tester med for eksempel Jasmine. Angular.js begynner å få stor utbredelse, er fortsatt ikke mye brukt i BEKK-prosjekter, men velges ofte på nye satsinger.","id":23423,"levelFactor":0.8237266803416079,"levelId":207,"name":"Angular.js","number":83,"sectorFactor":0.82809635371644275,"sectorId":315,"shape":"Circle","size":0},{"description":"Mustache og Handlebars er eksempler på templating-rammeverk som er blottet for logikk og kontrollstrukturer. Det finnes for mange plattformer, men vi bruker JS-varianten i web-applikasjoner, og da gjerne sammen med MVC-rammeverk. ","id":23424,"levelFactor":0.90803448403968778,"levelId":207,"name":"Templating-rammeverk","number":84,"sectorFactor":0.33121238007451692,"sectorId":315,"shape":"Circle","size":0},{"description":"HTML5 kommer med veldig mye snacks. Det har fortsatt vesentlige problemer med nettleser-støtte på stasjonære og bærbare maskiner, og er derfor mest relevant for mobilapplikasjoner. HTML5-shims kan være en løsning på dette.","id":23425,"levelFactor":0.318885778431659,"levelId":208,"name":"HTML5","number":85,"sectorFactor":0.42396918430410058,"sectorId":315,"shape":"Circle","size":0},{"description":"Browserstøtten kommer gradvis for CSS3, og er godt implementert i nettleserne på de store håndholdte plattformene. På grunn av manglende støtte i eldre browsere (typisk IE) bør det primært brukes for progressive enhancements.","id":23426,"levelFactor":0.62231887438157407,"levelId":207,"name":"CSS3","number":86,"sectorFactor":0.148805530597234,"sectorId":315,"shape":"Circle","size":0},{"description":"Window Phone 7.5 er så godt som historie etter at Microsoft lanserte 8.0 som et OS ikke bakoverkompatibelt når det gjelder hardware. De har kanskje ikke den største andelen innenfor smarttelefonmarkedet, men både antall enheter og andelen vokser og det er ingen grunn til å tro at Microsoft kommer til å legge ned sin telefonsatsning med det første. Likevel er det fortsatt den plattformen vi nesten alltid velger bort når vi lager mobilapplikasjoner. iOS og Android er et must - Windows Phone er det ikke.","id":23427,"levelFactor":0.18125200970402316,"levelId":207,"name":"Window Phone 8 Apps","number":87,"sectorFactor":0.8829896905258352,"sectorId":315,"shape":"Circle","size":0},{"description":"Sencha Touch er et stort JavaScript-rammeverk rettet mot mobilplattformer. Det har ingen avhengigheter til andre rammeverk, og det krever mindre kjennskap til HTML enn JavaScript-rammeverk som jQuery Mobile, Backbone, Angular og Ember. Sencha har mange ferdige komponenter og verktøy for å støtte oppunder applikasjonsutviklingen og kan være nyttig om man trenger et enkelt mobil-grensesnitt raskt. Det krever noe innsats å komme i gang, da det er stort og omfattende, og det oppleves litt lite tilpasningsdyktig for større og mer komplekse mobil-applikasjoner. Sencha er derfor lite brukt i BEKK-prosjekter.","id":23428,"levelFactor":0.26475998829349895,"levelId":207,"name":"Sencha Touch","number":88,"sectorFactor":0.54707105332287587,"sectorId":315,"shape":"Circle","size":0},{"description":"Android 4.2 er den nyeste API-versjonen for Android-utvikling. Nye features er blant annet støtte for eksterne skjermer, nøstede fragmenter og widgets for låsing av skjermen. Fortsatt bare et par prosents utbredelse på verdensbasis, men langt høyere i Norge. Når man utvikler native Android-apper er det viktig å ta hensyn til et bredt spekter av Android-versjoner helt tilbake til versjon 2.x, som faktisk er Android-versjonen med størst utbredelse pr mai 2013.","id":23429,"levelFactor":0.34538624963297765,"levelId":208,"name":"Android","number":89,"sectorFactor":0.1311381578642615,"sectorId":315,"shape":"Circle","size":0},{"description":"Appcelerator Titanium er et rammeverk for å utvikle javascript-baserte hybrid-applikasjoner rettet mot iOS og Android. Grunntanken er at utviklere skal kunne benytte sin eksisterende JS-kompetanse til å lage applikasjoner som kjører på JS-motorene i mobil-plattformene. Ytelsen blir ikke helt som for plattform-kompilert kode, og har til nylig primært blitt brukt til prototyping.","id":23430,"levelFactor":0.51575617450973077,"levelId":207,"name":"Appcelerator","number":90,"sectorFactor":0.2638832721429642,"sectorId":315,"shape":"Circle","size":0},{"description":"Xamarin for iOS og Android, tidligere MonoTouch og Mono for Android, lar utviklere lage apper for Windows 8, iOS og Android i C#\/.NET. Dette  åpner for stor grad av gjennbruk av kode på tvers av plattformene, samtidig som brukeropplevelsen er 100% \"native\".  Det er imidlertid viktig å være klar over at ved bruk av rammeverk for x-plattform, må man fortsatt forholde seg til teknologiene bak iOS, Android og WP. Det kommer i tillegg til at man gjør seg avhengig av et nytt 3-parts rammeverk.","id":23431,"levelFactor":0.474617561572014,"levelId":207,"name":"Xamarin","number":91,"sectorFactor":0.8240845931064199,"sectorId":315,"shape":"Circle","size":0},{"description":"iOS er selvskreven som plattform når man går for \"native\" mobilapper. Xcode og Objective-C fungerer bra som henholdsvis IDE og språk, og med iOS 5 SDKen kom storyboards, et utviklerverktøy for å effektivisere utviklingen av grensesnitt på iOS. Ved å benytte Storyboard, kan man som utvikler sette opp flyten i applikasjonen mellom de forskjellige skjermbildene. Det var få store nyheter for utviklere i iOS6, i hvert fall ikke for oss som fokuserer på bedriftssegmentet. Det viktigste var nok utvidelser i web-motoren for bedre HTML5- og CSS3-støtte. Betalingsmulighet inne i appen kan også være interessant for en del. 10. juni annonserte Apple iOS7, som ser ut til å være den største oppgraderingen av operativsystemet noensinne. Det vil være hensiktsmessig for utviklere tidlig å kartlegge hvilke konsekvenser dette får for sine apper, både fra et teknisk og et designmessig perspektiv.","id":23432,"levelFactor":0.366042196177578,"levelId":208,"name":"iOS App","number":92,"sectorFactor":0.87433408362199783,"sectorId":315,"shape":"Circle","size":0},{"description":"Jersey er en referanseimplementasjon av JAX-RS standarden (JSR311), som er bygget fra bunnen av for å gjøre det enkelt og effektivt å lage gode REST-tjenester i Java. Vi ser at Jersey i stadig større grad velges på nye prosjekter, gjerne i samspill med en JavaScript-klient.","id":23434,"levelFactor":0.511496853390185,"levelId":208,"name":"Jersey","number":93,"sectorFactor":0.74387443426141109,"sectorId":314,"shape":"Circle","size":0}],"published":"True","sectors":[{"id":312,"index":0,"name":"Prosess og kvalitet"},{"id":313,"index":1,"name":"Arkitektur og plattform"},{"id":314,"index":2,"name":"Språk og rammeverk"},{"id":315,"index":3,"name":"Frontend og mobil"}],"startDate":"\/Date(1371938400000+0200)\/","updateDate":"\/Date(1432720429660+0200)\/","url":"techradar2013"}
